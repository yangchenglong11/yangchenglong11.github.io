<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangcl&#39;s</title>
  
  <subtitle>悟已往之不谏，知来者之可追。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangchenglong11.github.io/"/>
  <updated>2017-09-24T06:15:16.000Z</updated>
  <id>https://yangchenglong11.github.io/</id>
  
  <author>
    <name>Yang Chenglong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker是什么</title>
    <link href="https://yangchenglong11.github.io/2016/11/15/Docker%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://yangchenglong11.github.io/2016/11/15/Docker是什么/</id>
    <published>2016-11-15T04:10:10.000Z</published>
    <updated>2017-09-24T06:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单说它是一个开源的容器引擎，可以帮助开发者高效的构建应用。<br><a id="more"></a> </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437250607&auto=0&height=66"></iframe><p>我们先看一下正常情况，我们是怎样构建一个简单应用的呢？首先它要有一个基础的平台，也就是操作系统来让它运行，比如 win，linux 等等。然后我们就可以写代码来实现它。在这个过程中，我们可能会用到数据库，框架等等。为了在代码中使用这些，我们会根据需要进行相关的配置，或者下载所需的依赖。但这个过程有时并不是想象中的那么简单，甚至有些时候仅仅是配置环境就让一些开发者望而却步。等我们所有的工作都完成后，将它部署到服务器上提供服务，我们的应用就开发完了，接着就是无休止的运维了。</p><p>为了更好的理解 Docker 是什么？我们把上面构建应用的过程比作运输货物，我们把上面提到的操作系统看作是进行运输的交通工具，这里我们就把大鲸鱼当作交通工具吧，把交付的应用程序看成是各种货物，我们要将各种各样形状、尺寸不同的货物放到大鲸鱼上，我们需要为每件货物考虑怎么安放（就是应用程序配套的环境），还得考虑货物和货物是否能叠起来（应用程序依赖的环境是否会冲突）。这可不是一份简单的差事，有时候因为安排不当甚至会导致这一次运输的失败。但后来出现了集装箱，我们把每件货物都放到集装箱里，这样我们的就可以用同样地方式安放、堆叠集装了，省事省力。</p><p>上面提到的集装箱就是 Docker 中的“容器”，而 Docker 就是管理这些集装箱的一整套机制。集装箱好像只是做了一层封装，没有什么很神奇的地方。但我们继续想象下场景，集装箱出现之后，世界上绝大多数的货物运输都可以放到这个神奇的箱子里，然后在公路、铁路、海洋等所有运输场景下，这个箱子都不用变化形态直接可以承运，而且中间的中转工作，都可以通过大型机械搞定，效率大大提升，从此生产力飙升。因为集装箱规范了运输的标准，于是相应的船舶、卡车、列车以及自动化中转设备才能按照规格，被制造出来，然后使联运以及自动化成为可能，才可以极大的提高效率，提升自动化水平。集装箱本身是一个产品，而这个产品无非就是标准化的具体体现，现实世界中的事实显而易见，就是这么简单。</p><p>按照这个思路，Docker 其实跟集装箱一样，或者说它想跟集装箱一样，成为穿着马甲的“标准化”。这样开发工程师就可以把它们开发出来的 bug 们放到“集装箱”里，然后运维人员就可以使用标准化的操作工具去运维这些可爱的 bug 们。于是实现了“海陆联运”，就好像运维工程师根本不需要了解其运维的软件架构而开发工程师也并不需要了解其软件运行的操作系统一样…… 总的来说，Docker 的目的是实现自动化运维，自动化运维的大前提是标准化，而 Docker 就是实现标准化的工具。</p><p>然后我们具体看看它能给开发和运维带来哪些福利。</p><p>它可以让我们更快速的交付和部署应用。使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用相同环境来部署代码。Docker 可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，各个步骤都有明确的配置和操作，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p><p>它可以实现更高效的资源利用。Docker 容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</p><p>它能帮我们更轻松的迁移和扩展。Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性让用户可以在不同平台之间轻松地迁移应用。同时 Docker 创造性的使用了类似 git 管理代码的方式对镜像进行管理，也方便我们进行获取和管理 Docker 镜像。</p><p>它可以帮助我们更简单进行更新管理。使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式进行分发和更新，从而实现自动化并且高效的容器管理。Dockerfile 就是你的文档，并且用来产生镜像。要改变 Docker 镜像中的环境，先改 Dockerfile，用它产生镜像就行了，保证文档和环境一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单说它是一个开源的容器引擎，可以帮助开发者高效的构建应用。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://yangchenglong11.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://yangchenglong11.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux中改变文件属性与权限</title>
    <link href="https://yangchenglong11.github.io/2016/11/13/Linux%E4%B8%AD%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>https://yangchenglong11.github.io/2016/11/13/Linux中改变文件属性与权限/</id>
    <published>2016-11-13T11:52:46.000Z</published>
    <updated>2017-09-26T06:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讲了在 Linux 中怎样改变文件的属性与权限。</p><a id="more"></a> <h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p><strong>chgrp改变文件所属用户组</strong></p><p>chgrp即为change group的简写，如果要改变文件的用户组，要被改变的用户组必须要在/etc/group文件中存在才行，否则就会显示错误，可以进入这个目录查看文件内容，但建议使用cat命令，不要使用vi/vim，因为一旦不慎修改了此文件，系统文件出错后果是很严重的。</p><p>改变之前：</p><pre><code>yangs-MacBook-Air:code yang$ ls -alyangs-MacBook-Air:code yang$ -rw-r--r--   1 yang  staff    14 Jan 12 17:01 te1</code></pre><p>执行命令：</p><pre><code>yangs-MacBook-Air:code yang$ chgrp everyone te1</code></pre><p>让我们查看一下：</p><pre><code>yangs-MacBook-Air:code yang$ ls -alyangs-MacBook-Air:code yang$ -rw-r--r--   1 yang  everyone    14 Jan 12 17:04 te1</code></pre><p>可以看到已经被修改了。</p><p>当所改用户组未在文件中时：</p><pre><code>yangs-MacBook-Air:code yang$ chgrp eve te1chgrp: eve: illegal group name</code></pre><p>这个命令还有一个可选参数 -R,即进行递归(recursive)的持续更改，即连同子目录下的所有文件目录都更新成为这个用户组，常用在更改某一目录内所有的文件情况。</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><strong>chown改变文件所有者</strong></p><p>chown即为 change owner 的简写，同样的，所改变的用户也必须是在/etc/passwd这个文件中有记录的用户名才可以。</p><p>chown 也可以直接修改用户组的名称，如果要连目录内所有子目录和文件都同时修改的话，直接加上-R即可。</p><pre><code>yangs-MacBook-Air:code yang$ chown bin te1// 下面这个是将 te1 的所有者与用户组都改为 rootyangs-MacBook-Air:code yang$ chown root:root</code></pre><p>可能你会有疑问，上述两个命令有什么用呢？最常见的例子就是复制文件给你之外的其他人时，比如使用cp命令：</p><pre><code>yangs-MacBook-Air:code yang$ cp 源文件 目标文件</code></pre><p>由于复制行为(cp)会复制执行者的属性与权限，那么对于其他人可能仍是无法修改此文件的。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><strong>chmod改变文件权限</strong></p><p>chmod 命令用来变更文件或目录的权限。</p><p>在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 </p><p>权限范围的表示法如下： </p><pre><code>- u User，即文件或目录的拥有者； - g Group，即文件或目录的所属群组； - o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围； - a All，即全部的用户，包含拥有者，所属群组以及其他用户； - r 读取权限，数字代号为“4”; w 写入权限，数字代号为“2”； - x 执行或切换权限，数字代号为“1”； - 不具任何权限，数字代号为“0”； - s 特殊功能说明：变更文件或目录的权限。 </code></pre><p>语法 chmod (选项) (参数) </p><p>  选项 </p><pre><code>- -c或——changes：效果类似“-v”参数，但仅回报更改的部分；- -f或--quiet或——silent：不显示错误信息； - -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理； - -v或——verbose：显示指令执行过程； - --reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同； - &lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置； - &lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置； - &lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置； </code></pre><p>参数 </p><ul><li>权限模式：指定文件的权限模式； </li><li>文件：要改变权限的文件。 </li></ul><hr><p>知识扩展: Linux 用户分为：拥有者、组群(Group)、其他（other），Linux 系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及 root 的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內。</p><hr><p>例：rwx　rw-　r– 　</p><p>r 为读取属性　　  // 值＝4 </p><p>w 为写入属性　　 // 值＝2 </p><p>x 为执行属性　　  // 值＝1　</p><pre><code>chmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限 chmod u=rwx,g=rw,o=r f01 chmod 764 f01 chmod a+x f01　　//对文件f01的u,g,o都设置可执行属性 文件的属主和属组属性设置 chown user:market f01　　//把文件f01给uesr，添加到market组 ll -d f1 查看目录f1的属性</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讲了在 Linux 中怎样改变文件的属性与权限。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yangchenglong11.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://yangchenglong11.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Go 字符串格式化</title>
    <link href="https://yangchenglong11.github.io/2016/10/21/Go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://yangchenglong11.github.io/2016/10/21/Go-字符串格式化/</id>
    <published>2016-10-21T07:12:53.000Z</published>
    <updated>2017-09-29T08:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>写代码时经常会用到字符串，这里总结下 Go 语言中常用的字符串格式化例子。</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</div><div class="line">x, y <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">// Go提供了几种打印格式，用来格式化一般的Go值</span></div><div class="line"><span class="comment">// 下面的%v打印了一个结构体的对象的值</span></div><div class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 如果所格式化的值是一个结构体对象，那么%+v的格式化输出将包括结构体的成员名称和值</span></div><div class="line">fmt.Printf(<span class="string">"%+v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// %#v格式化输出将输出一个值的Go语法表示方式。</span></div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%T来输出一个值的数据类型</span></div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%p输出一个指针的值</span></div><div class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%#p输出一个不带0x的指针的值</span></div><div class="line">fmt.Printf(<span class="string">"%#p\n"</span>, &amp;p)</div><div class="line"></div><div class="line"><span class="comment">// 格式化布尔型变量</span></div><div class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// 有很多的方式可以格式化整型，使用%d是一种标准的以10进制来输出整型的方式</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">123</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用%+d可以将符号也打印出来</span></div><div class="line">fmt.Printf(<span class="string">"%+d\n"</span>, <span class="number">123</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的二进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">14</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的不带零的八进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">16</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的带零的八进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%#o\n"</span>, <span class="number">16</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这里打印出该整型数值所对应的字符，即A对应的ASCII值</span></div><div class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">33</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出一个值的小写的十六进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出一个值的一个值的大写的十六进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%X\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出带0x的十六进制</span></div><div class="line">fmt.Printf(<span class="string">"%#x\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 浮点型数值也有几种格式化方法。最基本的一种是%f</span></div><div class="line">fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">78.9</span>)</div><div class="line"></div><div class="line"><span class="comment">// %e和%E使用科学计数法来输出整型</span></div><div class="line">fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">123400000.0</span>)</div><div class="line">fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">123400000.0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用%s输出基本的字符串</span></div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="string">"\"string\""</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出像Go源码中那样带双引号的字符串，需使用%q</span></div><div class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"\"string\""</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出字符串带反引号，但字符串内部不能有`字符</span></div><div class="line">fmt.Printf(<span class="string">"%#q\n"</span>, <span class="string">"string"</span>)</div><div class="line"></div><div class="line"><span class="comment">// %x以16进制输出字符串，每个字符串的字节用两个字符输出，大小写同前</span></div><div class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"hex this"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 当输出数字的时候，经常需要去控制输出的宽度和精度。可以使用一个位于%后面的数字来控制输出的宽度</span></div><div class="line"><span class="comment">// 默认情况下输出是右对齐的，左边加上空格</span></div><div class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以指定浮点数的输出宽度，同时你还可以指定浮点数的输出精度</span></div><div class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</div><div class="line"></div><div class="line"><span class="comment">// 用最少的数字来表示浮点数</span></div><div class="line">fmt.Printf(<span class="string">"%g\n"</span>, <span class="number">1.23</span>)</div><div class="line"></div><div class="line"><span class="comment">// 用最多3位数字来表示浮点数</span></div><div class="line">fmt.Printf(<span class="string">"%.3g\n"</span>, <span class="number">12.34</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 - 符号，进行左对齐</span></div><div class="line">fmt.Printf(<span class="string">"|%-6.3f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 %05d 符号， 会在数字前面补零。</span></div><div class="line">fmt.Printf(<span class="string">"%05d\n"</span>, <span class="number">43</span>)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以指定输出字符串的宽度来保证它们输出对齐。默认情况下，输出是右对齐的</span></div><div class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 为了使用左对齐你可以在宽度之前加上-号</span></div><div class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Printf函数的输出是输出到命令行os.Stdout的，你可以用Sprintf来将格式化后的字符串赋值给一个变量</span></div><div class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</div><div class="line">fmt.Println(s)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以使用Fprintf来将格式化后的值输出到io.Writers</span></div><div class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&#123;1 2&#125;</div><div class="line">&#123;x:1 y:2&#125;</div><div class="line">main.point&#123;x:1, y:2&#125;</div><div class="line">main.point</div><div class="line">0xc42007e010</div><div class="line">c42007e010</div><div class="line">true</div><div class="line">123</div><div class="line">+123</div><div class="line">1110</div><div class="line">20</div><div class="line">020</div><div class="line">!</div><div class="line">1c8</div><div class="line">1C8</div><div class="line">0x1c8</div><div class="line">78.900000</div><div class="line">1.234000e+08</div><div class="line">1.234000E+08</div><div class="line"><span class="string">"string"</span></div><div class="line"><span class="string">"\"string\""</span></div><div class="line">`string`</div><div class="line">6865782074686973</div><div class="line">|<span class="string">    12</span>|<span class="string">   345</span>|</div><div class="line">|<span class="string">  1.20</span>|<span class="string">  3.45</span>|</div><div class="line">1.23</div><div class="line">12.3</div><div class="line">|<span class="string">1.200 </span>|<span class="string">3.45  </span>|</div><div class="line">00043</div><div class="line">|<span class="string">   foo</span>|<span class="string">     b</span>|</div><div class="line">|<span class="string">foo   </span>|<span class="string">b     </span>|</div><div class="line">a string</div><div class="line">an error</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码时经常会用到字符串，这里总结下 Go 语言中常用的字符串格式化例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://yangchenglong11.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://yangchenglong11.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go 实现set</title>
    <link href="https://yangchenglong11.github.io/2016/10/17/Go-%E5%AE%9E%E7%8E%B0set/"/>
    <id>https://yangchenglong11.github.io/2016/10/17/Go-实现set/</id>
    <published>2016-10-17T01:23:34.000Z</published>
    <updated>2017-09-29T09:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>练习利用go语言的标准数据类型map实现python语言中的set数据结构。</p><a id="more"></a><p>其他语言中，set的底层都是由哈希表(Hash Table)来实现的，go语言拥有作为Hash Table实现的字典Map类型。我们在对Set和Map进行比较之后会发现他们在一些主要特性上是及其相似的如下：</p><ul><li>他们中的元素都是不可重复的。</li><li>他们都只能用迭代的方式取出其中的所有元素。</li><li>对他们中的元素进行迭代的顺序都是与元素插入顺序无关的，同时也不保证任何有序性，虽然有一些区别。</li><li>Set的元素是一个单一的值，而map的元素则是一个键值对。</li><li>Set的元素不可重复指的是不能存在任意两个单一值相等的情况。map的元素不可重复指的是任意两个键值对中的键的值不能相等。</li></ul><p>我们可以发现Set更像是Map的一种简化版本，我们可不可以利用Map来编写一个Set的实现呢？答案当然是肯定的。</p><p>基本定义</p><pre><code>首先，我们创建一个名为hash_set.go的源码文件，把它放在项目的代码包set中。我们需要首先在这个源码文件的第一行上写入这样一行代码：package set 这是为了声明源码文件hash_set.go是代码包set中的一员。然后我们声明一个包含了一个字典类型的字段的结构体类型。声明如下：type HashSet struct {    m map[interface{}]bool}这个类型声明中的唯一的字段是map[interface{}]bool。之所以选择这样的一个字典类型是有原因的。因为我们希望HashSet类型的元素可以是任意类型的，所以我们将字典m的键类型设置为了interface{}。又由于我们只需要用到m的值中的键来储存HashSet类型的元素值，所以就应该选用值占用空间最小的类型来作为m的值的元素类型，这里使用bool类型有3个好处：</code></pre><ul><li>从值的储存形式的角度看，bool类型值的占用空间是最小的之一，只占用一个字节。</li><li>从值的表示形式的角度看，bool类型的值只有两个，这两个值都是预定义常量。</li><li>把bool类型作为值类型更有利于判断字典类型中是否存在某个键。例如，我们可以用m[“a”]的结果值体现m的值中是否包含键为”a”键值对，但是，如果m的类型是map[interface{}]byte的话，那么我们只有通过v, ok := m[“a”],才能确切得出上述判断的结果。虽然在向map[interface{}]byte类型的m的值添加键值对的时候，我们可以总以非零值的byte类型值作为其中的元素的值，但是我们在做判断的时候就需要编写更多的代码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> v := m[<span class="string">"a"</span>]; v != <span class="number">0</span> &#123; <span class="comment">// 如果“m“中不存在以”"a"作为键的键值对</span></div><div class="line">    <span class="comment">// 省略若干语句</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对于map[interface&#123;&#125;]bool类型的值来说</span></div><div class="line"><span class="keyword">if</span> m[<span class="string">"a"</span>]&#123;  <span class="comment">// 如果“m“中不存在以”"a"作为键的键值对</span></div><div class="line">   <span class="comment">// 省略若干语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来我们考虑初始化HashSet类型值的问题。由于字典类型的零值为nil，所以我们不能简单使用new函数来创建一个HashSet类型值，因为 new(HashSet).m 的求值结果将会是一个 nil 。因此，这里需要编写一个专门用于创建和初始化 HashSet 类型值的函数，该函数声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHashSet</span><span class="params">()</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">      <span class="keyword">return</span> &amp;HashSet&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上可以看到，使用make函数对字段m进行了初始化。同时注意观察函数 NewHashSet 的结果声明的类型是 <em>HashSet 而不是 HashSet，目的是让这个结果值的方法集合中包含调用接收者类型为 HashSet 或 </em>HashSet 的所有方法。这样做的好处将在后面编写 Set 接口类型的时候再予以说明。</p><p>2.基本功能</p><p>依据其他编程语言中的 HashSet 类型可知，它们大部分应该提供的基本功能如下：</p><ul><li>添加元素值。</li><li>删除元素值。</li><li>清除所有元素值。</li><li>判断是否包含某个元素值。</li><li>获取元素值的数量。</li><li>判断与其他HashSet类型值是否相同。</li><li>获取所有元素值，即生成可迭代的快照。</li><li>获取自身的字符串表示形式。</li></ul><p>(1).添加元素值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法Add会返回一个bool类型的结果值，以表示添加元素值的操作是否成功。</span></div><div class="line"><span class="comment">// 方法Add的声明中的接收者类型是*HashSet。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Add</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">   <span class="keyword">if</span> !set.m[e] &#123;         <span class="comment">// 当前的m的值中还未包含以e的值为键的键值对</span></div><div class="line">      set.m[e] = <span class="literal">true</span>     <span class="comment">// 将键为e(代表的值)、元素为true的键值对添加到m的值当中</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>         <span class="comment">// 添加成功</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">false</span>           <span class="comment">// 添加失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用 *HashSet 而不是 HashSet，主要是从节约内存空间的角度出发，分析如下：</p><p>当 Add 方法的接收者类型为 HashSet 的时候，对它的每一次调用都需要对当前 HashSet 类型值进行一次复制。虽然在 HashSet 类型中只有一个引用类型的字段，但是这也是一种开销。而且这里还没有考虑 HashSet 类型中的字段可能会变得更多的情况。</p><p>当 Add 方法的接收者类型为 <em>HashSet 的时候，对它进行调用时复制的当前 </em>HashSet 的类型值只是一个指针值。在大多数情况下，一个指针值占用的内存空间总会被它指向的那个其他类型的值所占用的内存空间小。无论一个指针值指向的那个其他类型值所需的内存空间有多么大，它所占用的内存空间总是不变的。</p><p>(2).删除元素值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用delete内建函数删除HashSet内部支持的字典值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Remove</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line"><span class="built_in">delete</span>(set.m, e)<span class="comment">//第一个参数为目标字典类型，第二个参数为要删除的那个键值对的键</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(3).清除所有元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为HashSet中的字段m重新赋值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</div><div class="line">set.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果接收者类型是 HashSet，该方法中的赋值语句的作用只是为当前值的某个复制品中的字段m赋值而已，而当前值中的字段 m 则不会被重新赋值。方法 Clear 中的这条赋值语句被执行之后，当前的 HashSet 类型值中的元素就相当于被清空了。已经与字段 m 解除绑定的那个旧的字典值由于不再与任何程序实体存在绑定关系而成为了无用的数据。它会在之后的某一时刻被Go语言的垃圾回收器发现并回收。</p><p>(4).判断是否包含某个元素值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Contains用于判断其值是否包含某个元素值。</span></div><div class="line"><span class="comment">//这里判断结果得益于元素类型为bool的字段m</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Contains</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line"><span class="keyword">return</span> set.m[e]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当把一个 interface{} 类型值作为键添加到一个字典值的时候，Go语言会先获取这个 interface{} 类型值的实际类型（即动态类型），然后再使用与之对应的 hash 函数对该值进行 hash 运算，也就是说，interface{} 类型值总是能够被正确地计算出 hash 值。但是字典类型的键不能是函数类型、字典类型或切片类型，否则会引发一个运行时恐慌，并提示如下： </p><pre><code>panic: runtime error: hash of unhashable type &lt;某个函数类型、字典类型或切片类型的名称&gt;</code></pre><p>(5).获取元素值的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Len用于获取HashSet元素值数量</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(set.m)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(6).判断与其他HashSet类型值是否相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Same用来判断两个HashSet类型值是否相同</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Same</span><span class="params">(other *HashSet)</span> <span class="title">bool</span></span> &#123;</div><div class="line"><span class="keyword">if</span> other == <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> set.Len() != other.Len() &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> !other.Contains(key) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个 HashSet 类型值相同的必要条件是，它们包含的元素应该是完全相同的。由于 HashSet 类型值中的元素的迭代顺序总是不确定的，所以也就不用在意两个值在这方面是否一致。如果要判断两个 HashSet 类型值是否是同一个值，就需要利用指针运算进行内存地址的比较。</p><p>(7).获取所有元素值，即生成可迭代的快照。</p><p>所谓 快照，就是目标值在某一个时刻的映像。对于一个 HashSet 类型值来说，它的快照中的元素迭代顺序总是可以确定的，快照只反映了该 HashSet 类型值在某一个时刻的状态。另外，还需要从元素可迭代且顺序可确定的数据类型中选取一个作为快照的类型。这个类型必须是以单值作为元素的，所以字典类型最先别排除。又由于 HashSet 类型值中的元素数量总是不固定的，所以无法用一个数组类型的值来表示它的快照。如上分析可知，Go语言中可以使用的快照的类型应该是一个切片类型或者通道类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Elements用于生成快照</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Elements</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">initialLen := <span class="built_in">len</span>(set.m)</div><div class="line"><span class="comment">//初始化一个[]interface&#123;&#125;类型的变量snapshot来存储m的值中的元素值</span></div><div class="line">snapshot := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, initialLen)</div><div class="line">actualLen := <span class="number">0</span></div><div class="line"><span class="comment">//按照既定顺序将迭代值设置到快照值(变量snapshot的值)的指定元素位置上,这一过程并不会创建任何新值。</span></div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> actualLen &lt; initialLen &#123;</div><div class="line">snapshot[actualLen] = key</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">snapshot = <span class="built_in">append</span>(snapshot, key)</div><div class="line">&#125;</div><div class="line">actualLen++ <span class="comment">//实际迭代的次数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> actualLen &lt; initialLen &#123;</div><div class="line">snapshot = snapshot[:actualLen]</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> snapshot</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之所以我们使用这么多条语句来实现这个方法是因为需要考虑到在从获取字段m的值的长度到对m的值迭代完成的这个时间段内，m的值中的元素数量可能发生变化。如果在迭代完成之前，m的值中的元素数量有所增加，使得实际迭代的次数大于先前初始化的快照值的长度 ，那么我们再使用appeng函数向快照值追加元素值。这样做既提高了快照生成的效率，又不至于在元素数量增加时引发索引越界的运行时恐慌。</p><p>对于已被初始化的[]interface{}类型的切片值来说，未被显示初始化的元素位置上的值均为nil。如果在迭代完成前，m的值中的元素数量有所减少， 致使快照值的尾部存在若干个没有任何意义的值为nil的元素，我们需要把这些无用的元素从快照中去掉。可以通过snapshot = snapshot[:actualLen]将无用的元素值从快照值中去掉。</p><p>注意：在 Elements 方法中针对并发访问和修改 m 的值的情况采取了一些措施。但是由于m的值本身并不是并发安全的，所以并不能保证 Elements 方法的执行总会准确无误。要做到真正的并发安全，还需要一些辅助的手段，比如读写互斥量。</p><p>(8).获取自身的字符串表示形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个String方法的签名算是一个惯用法。</span></div><div class="line"><span class="comment">//代码包fmt中的打印函数总会使用参数值附带的具有如此签名的String方法的结果值作为该参数值的字符串表示形式。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line"><span class="keyword">var</span> buf bytes.Buffer <span class="comment">//作为结果值的缓冲区</span></div><div class="line">buf.WriteString(<span class="string">"HashSet&#123;"</span>)</div><div class="line">first := <span class="literal">true</span></div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> first &#123;</div><div class="line">first = <span class="literal">false</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">buf.WriteString(<span class="string">","</span>)</div><div class="line">&#125;</div><div class="line">buf.WriteString(fmt.Sprintf(<span class="string">"%v"</span>, key))</div><div class="line">&#125;</div><div class="line"><span class="comment">//n := 1</span></div><div class="line"><span class="comment">//for key := range set.m &#123;</span></div><div class="line"><span class="comment">// buf.WriteString(fmt.Sprintf("%v", key))</span></div><div class="line"><span class="comment">// if n == len(set.m) &#123;//最后一个元素的后面不添加逗号</span></div><div class="line"><span class="comment">// break;</span></div><div class="line"><span class="comment">// &#125; else &#123;</span></div><div class="line"><span class="comment">// buf.WriteString(",")</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">// n++;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">buf.WriteString(<span class="string">"&#125;"</span>)</div><div class="line"><span class="keyword">return</span> buf.Strin</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上已经完整地编写了一个具备常用功能的Set的实现类型，后面将讲解更多的高级功能来完善它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;练习利用go语言的标准数据类型map实现python语言中的set数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="https://yangchenglong11.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="https://yangchenglong11.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>假期小记</title>
    <link href="https://yangchenglong11.github.io/2016/10/08/%E5%81%87%E6%9C%9F%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yangchenglong11.github.io/2016/10/08/假期小记/</id>
    <published>2016-10-08T08:24:15.000Z</published>
    <updated>2017-09-25T04:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录了假期时看到的一些代码片段以及知识点，觉得不错就记录了下来。</p><a id="more"></a><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>Go 实现 map 排序</strong></p><pre><code>import &quot;sort&quot;var names []stringfor name := range ages {    names = append(names, name)}sort.Strings(names)for _, name := range names {    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])}</code></pre><p><strong>要判断两个 map 是否包含相同的 key 和 value，我们必须通过一个循环实现</strong>：</p><pre><code>func equal(x, y map[string]int) bool {    if len(x) != len(y) {        return false    }    for k, xv := range x {        if yv, ok := y[k]; !ok || yv != xv {            return false        }    }    return true}</code></pre><h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><p>Reader 接口的定义如下：</p><pre><code>type Reader interface {Read(p []byte) (n int, err error)}</code></pre><p>官方文档中关于该接口方法的说明：</p><pre><code>// Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。//当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。 一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的err不是EOF就是nil。无论如何，下一个 Read 都应当返回 0, EOF。//调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。</code></pre><p>也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。</p><h3 id="Writer-接口"><a href="#Writer-接口" class="headerlink" title="Writer 接口"></a>Writer 接口</h3><p>Writer 接口的定义如下：</p><pre><code>type Writer interface {Write(p []byte) (n int, err error)}</code></pre><p>官方文档中关于该接口方法的说明：</p><pre><code>//Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个非nil的错误。</code></pre><p>同样的，所有实现了 Write 方法的类型都实现了 io.Writer 接口。</p><p>实现了 io.Reade r接口或 io.Writer 接口的类型 </p><p>我们可以知道，os.File 同时实现了这两个接口。我们还看到 os.Stdin/Stdout 这样的代码，它们似乎分别实现了 io.Reader/io.Writer 接口。没错，实际上在 os 包中有这样的代码：</p><pre><code>var (    Stdin  = NewFile(uintptr(syscall.Stdin), &quot;/dev/stdin&quot;)    Stdout = NewFile(uintptr(syscall.Stdout), &quot;/dev/stdout&quot;)    Stderr = NewFile(uintptr(syscall.Stderr), &quot;/dev/stderr&quot;))</code></pre><p>也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件（即都是 os.File 的实例），自然也实现了 io.Reader 和io.Writer。</p><p>目前，Go 文档中还没法直接列出实现了某个接口的所有类型。不过，我们可以通过查看标准库文档，列出实现了io.Reader 或 io.Writer 接口的类型（导出的类型）：</p><pre><code>- os.File 同时实现了io.Reader和io.Writer- strings.Reader 实现了io.Reader- bufio.Reader/Writer 分别实现了io.Reader和io.Writer- bytes.Buffer 同时实现了io.Reader和io.Writer- bytes.Reader 实现了io.Reader- compress/gzip.Reader/Writer 分别实现了io.Reader和io.Writer- crypto/cipher.StreamReader/StreamWriter 分别实现了io.Reader和io.Writer- crypto/tls.Conn 同时实现了io.Reader和io.Writer- encoding/csv.Reader/Writer 分别实现了io.Reader和io.Writer- mime/multipart.Part 实现了io.Reader</code></pre><p>除此之外，io 包本身也有这两个接口的实现类型。如：</p><p>实现了Reader 的类型：LimitedReader、PipeReader、SectionReader</p><p>实现了 Writer 的类型：PipeWriter</p><p>以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片可以看作是对数组的一种包装形式，它所包装的数组称为该切片的底层数组。换句话说，切片是针对其底层数组中某个连续片段的描述符。</p><p>一个切片值总会持有一个对某个数组值的引用，事实上，一个切片值一旦被初始化，就会与一个包含了其中元素值的数组值相关联，即底层数组。多个切片值可能会共同用同一个底层数组。例如，如果把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的切片值，那么这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对底层数组上的对应元素的修改。从这个角度看，切片类似于指向底层数组的指针。反过来讲，对作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片值上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录了假期时看到的一些代码片段以及知识点，觉得不错就记录了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="https://yangchenglong11.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="https://yangchenglong11.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Web 后端和 GO</title>
    <link href="https://yangchenglong11.github.io/2016/10/03/Web-%E5%90%8E%E7%AB%AF%E5%92%8CGO/"/>
    <id>https://yangchenglong11.github.io/2016/10/03/Web-后端和GO/</id>
    <published>2016-10-03T14:10:10.000Z</published>
    <updated>2017-09-29T08:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>用最简单的话解释后端就是数据的处理，而前端是数据的呈现。<br><a id="more"></a> </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=473740555&auto=1&height=66"></iframe><p>根据正在处理的应用程序的大小和范围，后端开发人员要做的事情有很大的不同。以我的工作范围来说，实现业务逻辑，数据的创建和检索以及处理前端请求等。</p><p>在Web开发世界中，大多数后端开发人员从事于构建他们正在工作的应用程序背后的实际逻辑。</p><p>通常，前端开发人员构建用户界面，而后端开发人员编写代码，使其工作。</p><p>例如，前端开发人员在应用程序中创建一个界面，上面有一个按钮，按下按钮来获取客户的数据。</p><p>后端开发人员写可使得按钮工作的代码，通过指出从数据库中提取哪些数据并将其传回到前端（并最终显示在那里）。</p><p>后端开发人员也可能会大量参与系统架构，决定如何组织系统的逻辑，以便能够正常维护和运行。</p><p>他可能会参与构建框架或系统架构，以便于更容易编写程序。后端开发人员比前端开发人员花费更多的时间在实现算法和解决问题上。</p><p>这并不是说前端开发人员不解决难题，但是通常来说更难的功能实现，实际的业务逻辑都会再后端做。</p><h3 id="学后端需要学什么"><a href="#学后端需要学什么" class="headerlink" title="学后端需要学什么"></a>学后端需要学什么</h3><ul><li>后端开发语言<br>如：Golang，python，java，php，c#…..能够使用一门或多门开发语言来构造应用</li><li>数据库<br>掌握基本的增删改查，知道常见的数据库的优化以及运维，能够分析各种数据库的优缺点，知道什么时候用哪个数据库合适。</li><li>Linux使用</li><li>网络编程<br>熟悉掌握 http tcp/ip 协议</li><li>算法与数据结构</li><li>大数据</li><li>机器学习<br>……..<br>所以,路还是很长的….</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>我觉得学习一门语言最重要的就是做到三点,第一看基础知识,第二学习看代码,第三学习写代码.</p><p>  首先是基础语法<br>  有句话叫“基础不牢，地动山摇”。所以基础知识对以后的学习是很重要的，不只是语言方面，像上面说的数据库，网络之类的也是如此。重要，但不代表说我没有彻底掌握之前就停滞不前，就和它死磕到底，这并不是明智的做法。</p><p>  同时，也要注意，不要只看语法，也要有练习。golang官网就比较好，它有语法的文字描述，同时在旁边就有根据该语法给出的实例程序，加深理解。<br>  大家都已经学或正在学c++，其他语言就基础层面来说，简单的使用来说不会有太大差别。所以要学习其他语言，不必想c++这样花上将近一年的时间去学，把语法看下，大概有个印象就差不多了。不必要求全部记得，实际码代码时又不是考试，忘了可以回去查阅相关资料。</p><p>  接下来就是练习<br>  语法看完了，就像你们现在，c++学的差不多了，却不知道拿它能做什么。觉得语法好像是懂了，但怎么运用呢？<br>  我们要学会站在巨人的肩膀上，网上开源代码那么多，自己不会写，可以找一些大神写的自己感兴趣的源码clone到本地，仔细阅读分析他对语法是怎么运用的。</p><p>  当然，你down到本地的代码大多数不会只是讲解语法，因为这些开源出去的代码都是完成了某一功能的。简单的一些可能是利用这个语言实现了该语言所没有的数据结构，有的可能是一个网站的源码。<br>  这个阶段也是你提升最快的阶段，通过阅读源码，你可以学习到许多其他方面的知识，积累了经验。</p><p>  然后就是写了<br>  读书破万卷，下笔如有神。看了这么多源码，你也手痒了吧！来做一个项目练练手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用最简单的话解释后端就是数据的处理，而前端是数据的呈现。&lt;br&gt;
    
    </summary>
    
      <category term="后台" scheme="https://yangchenglong11.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="GO" scheme="https://yangchenglong11.github.io/tags/GO/"/>
    
      <category term="后台" scheme="https://yangchenglong11.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go 程序的基本结构和要素</title>
    <link href="https://yangchenglong11.github.io/2016/10/03/Go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/"/>
    <id>https://yangchenglong11.github.io/2016/10/03/Go-程序的基本结构和要素/</id>
    <published>2016-10-03T02:23:14.000Z</published>
    <updated>2017-09-25T05:21:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍 Go 语言的基本信息。</p><a id="more"></a><h3 id="Go-环境变量"><a href="#Go-环境变量" class="headerlink" title="Go 环境变量"></a>Go 环境变量</h3><p>Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之间就已经设置好他们。</p><p>如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：</p><ul><li><code>$GOROOT</code> 表示 Go 在你的电脑上的安装位置，它的值一般都是 <code>$HOME/go</code>，当然，你也可以安装在别的地方。</li><li><code>$GOARCH</code> 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li><li><code>$GOOS</code> 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li><li><code>$GOBIN</code> 表示编译器和链接器的安装位置，默认是 <code>$GOROOT/bin</code>，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。</li></ul><p>目标机器是指你打算运行你的 Go 应用程序的机器。</p><p>Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。</p><p>为了区分本地机器和目标机器，你可以使用 <code>$GOHOSTOS</code> 和 <code>$GOHOSTARCH</code> 设置目标机器的参数，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（<code>$GOOS</code> 和 <code>$GOARCH</code>）一样。</p><ul><li><code>$GOPATH</code> 默认采用和 <code>$GOROOT</code> 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</li><li><code>$GOARM</code> 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。</li><li><code>$GOMAXPROCS</code> 用于设置应用程序可使用的处理器个数与核数</li></ul><h3 id="包的概念、导入与可见性"><a href="#包的概念、导入与可见性" class="headerlink" title="包的概念、导入与可见性"></a>包的概念、导入与可见性</h3><p>包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line">    </div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   fmt.Println(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p><p>你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p><p>一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 <code>package main</code> 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 <code>pkg\windows_386</code> 中；在 Linux 下，标准库在 Go 根目录下的子目录 <code>pkg\linux_amd64</code> 中（如果是安装的是 32 位，则在 linux<em>386 目录中）。一般情况下，标准包会存放在 `$GOROOT/pkg/$GOOS</em>$GOARCH/` 目录下。</p><p>Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。</p><p>如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。</p><p>属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。</p><p>如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。</p><p>Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。</p><p>如果 A.go 依赖 B.go，而 B.go 又依赖 C.go：</p><ul><li>编译 C.go, B.go, 然后是 A.go.</li><li>为了编译 A.go, 编译器读取的是 B.o 而不是 C.o.</li></ul><p>这种机制对于编译大型的项目时可以显著地提升编译速度。</p><p><strong>每一段代码只会被编译一次</strong></p><p>一个 Go 程序是通过 import 关键字将一组包链接在一起。</p><p><code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 “” 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。</p><p>如果需要多个包，它们可以被分别导入：</p><pre><code>import &quot;fmt&quot;import &quot;os&quot;</code></pre><p>或：</p><pre><code>import &quot;fmt&quot;; import &quot;os&quot;</code></pre><p>但是还有更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义）：</p><pre><code>import (   &quot;fmt&quot;   &quot;os&quot;)</code></pre><p>它甚至还可以更短的形式，但使用 gofmt 后将会被强制换行：</p><pre><code>import (&quot;fmt&quot;; &quot;os&quot;)</code></pre><p>当你导入多个包时，导入的顺序会按照字母排序。</p><p>如果包名不是以 . 或 / 开头，如 “fmt” 或者 “container/list”，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。</p><p>导入包即等同于包含了这个包的所有的代码对象。</p><p>除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。</p><p>包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：</p><h3 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h3><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><p>（大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。</p><p>因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。</p><p>假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。</p><p>因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 <code>pack1.Thing</code> 和 <code>pack2.Thing</code>。</p><p>你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：<code>import fm &quot;fmt&quot;</code>。下面的代码展示了如何使用包的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line">    </div><div class="line"><span class="keyword">import</span> fm <span class="string">"fmt"</span> <span class="comment">// alias3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fm.Println(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意事项 </p><p>如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 <code>imported and not used: os</code>，这正是遵循了 Go 的格言：“没有不必要的代码！“。</p><p>包的分级声明和初始化</p><p>你可以在使用 import 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用（如 gotemplate.go 源文件中的 c 和 v），然后声明一个或多个函数（func）。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>这是定义一个函数最简单的格式：</p><pre><code>func functionName()</code></pre><p>你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。</p><p>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 <code>undefined: main.main</code>。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误： </p><pre><code>func main must have no arguments and no return values results.</code></pre><p>在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 <code>main.main()</code>（如：C 语言），该函数一旦返回就表示程序已成功执行并立即退出。</p><p>函数里的代码（函数体）使用大括号 {} 括起来。</p><p>左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示：</p><pre><code>`build-error: syntax error: unexpected semicolon or newline before {`</code></pre><p>（这是因为编译器会产生 func main() ; 这样的结果，很明显这错误的）</p><p>Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误 。</p><p>右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行：</p><pre><code>func Sum(a, b int) int { return a + b }</code></pre><p>对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。</p><p>因此符合规范的函数一般写成如下的形式：</p><pre><code>func functionName(parameter_list) (return_value_list) {   …}</code></pre><p>其中：</p><ul><li><code>parameter_list</code> 的形式为 <code>(param1 type1, param2 type2, …)</code></li><li><code>return_value_list</code> 的形式为 <code>(ret1 type1, ret2 type2, …)</code></li></ul><p>只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。</p><p>下面这一行调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \n：</p><pre><code>fmt.Println（&quot;hello, world&quot;）</code></pre><p>使用 <code>fmt.Print(&quot;hello, world\n&quot;)</code> 可以得到相同的结果。</p><p>Print 和 Println 这两个函数也支持使用变量，如：<code>fmt.Println(arr)</code>。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</p><p>单纯地打印一个字符串或变量甚至可以使用预定义的方法来实现，如：<code>print、println 、 print(&quot;ABC&quot;)、println(&quot;ABC&quot;)、println(i)（带一个变量 i）</code>。</p><p>这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 fmt 中的相关函数。</p><p>当被调用函数的代码执行到结束符 } 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。</p><p>程序正常退出的代码为 0 即 <code>Program exited with code 0</code>；如果程序因为异常而被终止，则会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code>package mainimport &quot;fmt&quot; // Package implementing formatted I/O.func main() {   fmt.Printf(&quot;Καλημέρα κόσμε; or こんにちは 世界\n&quot;)}</code></pre><p>上面这个例子通过打印 <code>Καλημέρα κόσμε; or こんにちは 世界</code> 展示了如何在 Go 中使用国际化字符，以及如何使用注释。</p><p>注释不会被编译，但可以通过 godoc 来使用（第 3.6 节）。</p><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</p><p>每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可。当开发人员需要了解包的一些情况时，自然会用 godoc 来显示包的文档说明，在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起。另外，在多段注释之间应以空行分隔加以区分。</p><p>示例：</p><pre><code>// Package superman implements methods for saving the world.//// Experience has shown that a small number of procedures can prove// helpful when attempting to save the world.package superman</code></pre><p>几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 “Abcd…” 作为开头。</p><p>示例：</p><pre><code>// enterOrbit causes Superman to fly into low Earth orbit, a position// that presents several possibilities for planet salvation.func enterOrbit() error {   ...}</code></pre><p>godoc 工具（第 3.6 节）会收集这些注释并产生一个技术文档。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>可以包含数据的变量（或常量），可以使用不同的数据类型或类型来保存数据。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。</p><p>类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。</p><p>结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。</p><p>函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：</p><pre><code>func FunctionName (a typea, b typeb) typeFunc</code></pre><p>你可以在函数体中的某处返回使用类型为 typeFunc 的变量 var：</p><pre><code>return var</code></pre><p>一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如：</p><pre><code>func FunctionName (a typea, b typeb) (t1 type1, t2 type2)</code></pre><p>示例： 函数 Atoi (第 4.7 节)：func Atoi(s string) (i int, err error)</p><p>返回的形式：</p><pre><code>return var1, var2</code></pre><p>这种多返回值一般用于判断某个函数是否执行成功（true/false）或与其它返回值一同返回错误消息（详见之后的并行赋值）。</p><p>使用 type 关键字可以定义你自己的类型，你可能想要定义一个结构体(第 10 章)，但是也可以定义一个已经存在的类型的别名，如：</p><pre><code>type IZ int</code></pre><p>这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。</p><p>然后我们可以使用下面的方式声明变量：</p><pre><code>var a IZ = 5</code></pre><p>这里我们可以看到 int 是变量 a 的底层类型，这也使得它们之间存在相互转换的可能（第 4.2.6 节）。</p><p>如果你有多个类型需要定义，可以使用因式分解关键字的方式，例如：</p><pre><code>type (   IZ int   FZ float64   STR string)</code></pre><p>每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言。</p><h3 id="Go-程序的一般结构"><a href="#Go-程序的一般结构" class="headerlink" title="Go 程序的一般结构"></a>Go 程序的一般结构</h3><p>下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。</p><p>所有的结构将在这一章或接下来的章节中进一步地解释说明，但总体思路如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> c = <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> v <span class="keyword">int</span> = <span class="number">5</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">// initialization of package</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span></div><div class="line">Func1()</div><div class="line"><span class="comment">// ...</span></div><div class="line">fmt.Println(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Method1</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func1</span><span class="params">()</span></span> &#123; <span class="comment">// exported function Func1</span></div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Go 程序的执行（程序启动）顺序如下：</p><ol><li>按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：</li><li>如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。</li><li>然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。</li><li>在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><pre><code>valueOfTypeB = typeB(valueOfTypeA)</code></pre><p>类型 B 的值 = 类型 B(类型 A 的值)</p><p>示例： </p><pre><code>a := 5.0b := int(a)</code></pre><p>但这只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）。当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。</p><p>具有相同底层类型的变量之间可以相互转换：</p><pre><code>var a IZ = 5c := int(a)d := IZ(c)</code></pre><h3 id="Go-命名规范"><a href="#Go-命名规范" class="headerlink" title="Go 命名规范"></a>Go 命名规范</h3><p>干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 Get… 之类的字符，如果是用于修改某个对象，则使用 SetName。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍 Go 语言的基本信息。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="https://yangchenglong11.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="https://yangchenglong11.github.io/tags/GO/"/>
    
  </entry>
  
</feed>
