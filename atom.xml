<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangcl&#39;s</title>
  
  <subtitle>悟已往之不谏，知来者之可追。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangchenglong11.github.io/"/>
  <updated>2017-10-03T11:53:31.511Z</updated>
  <id>https://yangchenglong11.github.io/</id>
  
  <author>
    <name>Yang Chenglong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB基础</title>
    <link href="https://yangchenglong11.github.io/2016/11/28/MongoDB%E5%9F%BA%E7%A1%80/"/>
    <id>https://yangchenglong11.github.io/2016/11/28/MongoDB基础/</id>
    <published>2016-11-28T08:24:15.000Z</published>
    <updated>2017-10-03T11:53:31.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br><a id="more"></a><br>它是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>MongoDB非常强大，同时也非常容易上手。这里介绍一些MongoDB的基本概念。</p><ul><li>文档是MongoDB中的数据单元，非常类似于关系数据库管理系统中的行（但是比行要复杂得多）。</li><li>集合可以看作没有模式的表。</li><li>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。</li><li>MongoDB自带简洁但功能强大的JavaScript shell，用来管理MongoDB实例和操作数据。</li><li>每一个文档都有一个特殊的键”_id”,它在文档所处的集合中是唯一的。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里先介绍 mac 下如何安装，然后介绍使用 docker 进行安装。</p><h2 id="mac下安装"><a href="#mac下安装" class="headerlink" title="mac下安装"></a>mac下安装</h2><ul><li>首先，下载好Mongodb数据库，然后再打开下载好的文件；</li><li>在终端中，选择合适的位置，输入： sudo mkdir -p /data/db，创建数据库日志文件夹；</li><li>在终端输入：sudo chown -R  用户名 /data/db ，给予数据库日志文件夹操作权限；</li><li>进入 mongodb 的 “bin”目录，使用命令“ ./mongod ”启动mongoDB server，启动成功后最后一行应该是端口号，到这里Mongodb已经安装成了；</li><li>新建终端窗口，并输入 ./mongo ，登陆到数据库，接下来就可以进行操作了。</li></ul><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>首先把 docker 镜像 pull 下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker pull mongo</div></pre></td></tr></table></figure><p>然后启动 mongo 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name mongo-name -v /home/docker/mongo_data:/data/db -d -p 27047:27017 mongo</div></pre></td></tr></table></figure><p>上面的命令中，我们创建一个mongo 容器，mongo-name 就是其名字， -v参数挂载本地目录 /home/docker/mongo_data 到容器的 /data/db 目录作为数据卷，-d参数使其在后台运行，-p 参数设置端口，使外界可以通过27047端口访问容器内27017端口，连接数据库。</p><p>mongo 镜像已经启动，我们可以使用下面的命令进入 mongo 进行操作 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo docker exec -it mongo-name mongo</div></pre></td></tr></table></figure><p>接下来再介绍下mongo 的常用命令。</p><h2 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h2><p>首先是连接 mongo 服务，即启动客户端。如果要在27017端口连接本地的 mongo  服务，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mogno</div></pre></td></tr></table></figure><p>如果要连接远端的mongo 服务，则稍微麻烦点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo xx.xx.xx.xx:port</div></pre></td></tr></table></figure><p>如果想退出mongo 客户端，输入 <code>exit</code>即可。</p><p>那如何关闭 mongo 服务呢？正常情况下我们可能会使用 <code>exit</code>或者<code>Ctrl+C</code>退出，但这样做是有隐患的，可能会导致数据丢失，或者无法再次启动mongo 服务，正确的做法是下面这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> use admin</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> db.shutdownServer()</span></div></pre></td></tr></table></figure><p>然后就是各种操作了～～～</p><h2 id="db"><a href="#db" class="headerlink" title="db"></a>db</h2><p>查看当前使用的数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">yangs-Air</span><span class="params">(mongod-<span class="number">3.4</span>.<span class="number">0</span>)</span></span> &gt; db</div><div class="line">test</div></pre></td></tr></table></figure><p>切换数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">yangs-Air</span><span class="params">(mongod-<span class="number">3.4</span>.<span class="number">0</span>)</span></span> &gt; use admin</div><div class="line">switched to db admin</div></pre></td></tr></table></figure><p>查看MongoDB实例拥有哪些数据库</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">yangs-Air</span>(<span class="selector-tag">mongod-3</span><span class="selector-class">.4</span><span class="selector-class">.0</span>) &gt; <span class="selector-tag">show</span> <span class="selector-tag">dbs</span>;</div><div class="line"><span class="selector-tag">admin</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">analy</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">github</span> → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">local</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">media</span>  → 0<span class="selector-class">.001GB</span></div><div class="line"><span class="selector-tag">test</span>   → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">test2</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">test3</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">test4</span>  → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">user</span>   → 0<span class="selector-class">.000GB</span></div><div class="line"><span class="selector-tag">work</span>   → 0<span class="selector-class">.000GB</span></div></pre></td></tr></table></figure><p>不需要显式创建数据库，当向数据库的某个collection插入文档时，数据库就被创建</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">yangs-Air(mongod-3.4.0) test&gt; show dbs</div><div class="line">admin  → 0.000GB</div><div class="line">analy  → 0.000GB</div><div class="line">test   → 0.000GB</div><div class="line">local  → 0.000GB</div><div class="line">yangs-Air(mongod-3.4.0) test&gt; use user</div><div class="line">switched <span class="keyword">to</span> db user</div><div class="line">yangs-Air(mongod-3.4.0) github&gt; show dbs</div><div class="line">admin → 0.000GB</div><div class="line">analy → 0.000GB</div><div class="line">local → 0.000GB</div><div class="line">test  → 0.000GB</div><div class="line">yangs-Air(mongod-3.4.0) user&gt; db.users.insert(&#123;<span class="string">"name"</span>:<span class="string">"yang"</span>&#125;)</div><div class="line">Inserted 1 record(s) <span class="keyword">in</span> 87ms</div><div class="line">WriteResult(&#123;</div><div class="line">  <span class="string">"nInserted"</span>: 1</div><div class="line">&#125;)</div><div class="line">yangs-Air(mongod-3.4.0) user&gt; show dbs</div><div class="line">admin  → 0.000GB</div><div class="line">analy  → 0.000GB</div><div class="line">local  → 0.000GB</div><div class="line">test   → 0.000GB</div><div class="line">user   → 0.000GB</div></pre></td></tr></table></figure><p>有一些数据库名是保留的，可以直接访问这些具有特殊语义的数据库，同时自己命名数据库时注意不要使用这些名字。</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>mongo是一个简化的javaScript shell，shell内置了帮助文档，使用help查看</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">yangs-Air(mongod-3.4.0) github&gt; <span class="keyword">help</span></div><div class="line"><span class="keyword">db</span>.<span class="keyword">help</span>()                    <span class="keyword">help</span> <span class="keyword">on</span> <span class="keyword">db</span> methods</div><div class="line"><span class="keyword">db</span>.mycoll.<span class="keyword">help</span>()             <span class="keyword">help</span> <span class="keyword">on</span> collection methods</div><div class="line"><span class="keyword">sh</span>.<span class="keyword">help</span>()                    sharding helpers</div><div class="line">rs.<span class="keyword">help</span>()                    replica <span class="keyword">set</span> helpers</div><div class="line"><span class="keyword">help</span> admin                   administrative <span class="keyword">help</span></div><div class="line">......</div><div class="line"><span class="keyword">exit</span>                         quit the mongo <span class="keyword">shell</span></div></pre></td></tr></table></figure><p>通过db.help()查看数据库级别的帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> db.help()</span></div><div class="line">DB methods:</div><div class="line">db.auth(username, password)</div><div class="line">db.createCollection(name, &#123; size : ..., capped : ..., max : ... &#125; )</div><div class="line">db.createView(name, viewOn, [ &#123; $operator: &#123;...&#125;&#125;, ... ], &#123; viewOptions &#125; )</div><div class="line">db.createUser(userDocument)</div><div class="line">......</div><div class="line">db.dropDatabase()</div><div class="line">db.eval() - deprecated</div><div class="line">db.getName()</div><div class="line">db.getPrevError()</div><div class="line">db.printSlaveReplicationInfo()</div><div class="line">db.dropUser(username)</div><div class="line">db.shutdownServer()</div><div class="line">db.stats()</div><div class="line">db.version() current version of the server</div></pre></td></tr></table></figure><p>使用db.foo.help()查看集合级别的帮助:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span><span class="bash"> db.foo.help()</span></div><div class="line">DBCollection help</div><div class="line">db.foo.find().help() - show DBCursor help</div><div class="line">db.foo.find(...).count()</div><div class="line">db.foo.find(...).limit(n)</div><div class="line">......</div><div class="line">db.foo.findOne([query], [fields], [options], [readConcern])</div><div class="line">db.foo.latencyStats() - display operation latency histograms for this collection</div></pre></td></tr></table></figure><p>在shell中输入函数名，不加小括号，就可以看到相应函数的JavaScript实现代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&gt; db.user.find</div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">query, fields, limit, skip, batchSize, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cursor = <span class="keyword">new</span> DBQuery(<span class="keyword">this</span>._mongo,</div><div class="line">                             <span class="keyword">this</span>._db,</div><div class="line">                             <span class="keyword">this</span>,</div><div class="line">                             <span class="keyword">this</span>._fullName,</div><div class="line">                             <span class="keyword">this</span>._massageObject(query),</div><div class="line">                             fields,</div><div class="line">                             limit,</div><div class="line">                             skip,</div><div class="line">                             batchSize,</div><div class="line">                             options || <span class="keyword">this</span>.getQueryOptions());</div><div class="line"></div><div class="line">    <span class="keyword">var</span> connObj = <span class="keyword">this</span>.getMongo();</div><div class="line">    <span class="keyword">var</span> readPrefMode = connObj.getReadPrefMode();</div><div class="line">    <span class="keyword">if</span> (readPrefMode != <span class="literal">null</span>) &#123;</div><div class="line">        cursor.readPref(readPrefMode, connObj.getReadPrefTagSet());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> rc = connObj.getReadConcern();</div><div class="line">    <span class="keyword">if</span> (rc) &#123;</div><div class="line">        cursor.readConcern(rc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cursor;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="shell中的基本操作"><a href="#shell中的基本操作" class="headerlink" title="shell中的基本操作"></a>shell中的基本操作</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><strong>insert即向 collection添加新的 documents.如果插入时集合不存在,插入操作会创建该集合。</strong></p><p>MongoDB中提供了以下方法来插入文档到一个集合:</p><ul><li>db.collection.insert()</li><li>db.collection.insertOne()</li><li>db.collection.insertMany()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.COLLECTION_NAME.insert(document)</div></pre></td></tr></table></figure><p><strong>实例</strong></p><p><strong>db.collection.insert()向集合插入一个或多个文档.要想插入一个文档,传递一个文档给该方法;要想插入多个文档,传递文档数组给该方法.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.col.insert(&#123;&quot;name&quot;:&quot;test&quot;&#125;)</div></pre></td></tr></table></figure><p>该操作返回了含有操作状态的 WriteResult对象.插入文档成功返回如下WriteResult 对象:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></div></pre></td></tr></table></figure><p>nInserted字段指明了插入文档的总数.如果该操作遇到了错误, WriteResult 对象将包含该错误信息.</p><p>下面我们看下插入多个文档时的情况：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.insert(</div><div class="line">...    [</div><div class="line">...      &#123; <span class="string">name:</span> <span class="string">"bob"</span>, <span class="string">age:</span> <span class="number">42</span>, <span class="string">status:</span> <span class="string">"A"</span>, &#125;,</div><div class="line">...      &#123; <span class="string">name:</span> <span class="string">"ahn"</span>, <span class="string">age:</span> <span class="number">22</span>, <span class="string">status:</span> <span class="string">"A"</span>, &#125;,</div><div class="line">...      &#123; <span class="string">name:</span> <span class="string">"xi"</span>, <span class="string">age:</span> <span class="number">34</span>, <span class="string">status:</span> <span class="string">"D"</span>, &#125;</div><div class="line">...    ]</div><div class="line">... )</div></pre></td></tr></table></figure><p>该方法返回了包含操作状态的 BulkWriteResult对象.成功插入文档返回如下 BulkWriteResult对象:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BulkWriteResult(&#123;</div><div class="line"><span class="string">"writeErrors"</span> : [ ],</div><div class="line"><span class="string">"writeConcernErrors"</span> : [ ],</div><div class="line"><span class="string">"nInserted"</span> : 3,</div><div class="line"><span class="string">"nUpserted"</span> : 0,</div><div class="line"><span class="string">"nMatched"</span> : 0,</div><div class="line"><span class="string">"nModified"</span> : 0,</div><div class="line"><span class="string">"nRemoved"</span> : 0,</div><div class="line"><span class="string">"upserted"</span> : [ ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>现在我们可以调用find()查看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; db.col.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5870c0b3d599544ddbd1d575&quot;), &quot;name&quot; : &quot;test&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5870cf70d599544ddbd1d579&quot;), &quot;name&quot; : &quot;bob&quot;, &quot;age&quot; : 42, &quot;status&quot; : &quot;A&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5870cf70d599544ddbd1d57a&quot;), &quot;name&quot; : &quot;ahn&quot;, &quot;age&quot; : 22, &quot;status&quot; : &quot;A&quot; &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5870cf70d599544ddbd1d57b&quot;), &quot;name&quot; : &quot;xi&quot;, &quot;age&quot; : 34, &quot;status&quot; : &quot;D&quot; &#125;</div></pre></td></tr></table></figure><p>可以看到已经插入成功，但每个文档都多了一个字段：”_id”,它是那里来的呢？</p><p><strong>MongoDB中储存的文档必须有一个”_id”键。这个键可以是任意类型的，默认为ObjectId对象。在一个集合中，每个文档都有唯一的”_id”值，来确保集合里面每个文档都能被唯一标识。如果插入文档的时候没有”_id”键,系统会自动帮你创建一个。这就是为什会多出来一个”_id”字段。</strong></p><p>接下来看下另外两个函数。</p><p><strong>db.collection.insertOne() 向集合插入单个document。</strong></p><p><strong>db.collection.insertMany()向集合插入多个 documents。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; db.users.insertMany(</div><div class="line">   [</div><div class="line">     &#123; name: &quot;bob&quot;, age: 42, status: &quot;A&quot;, &#125;,</div><div class="line">     &#123; name: &quot;ahn&quot;, age: 22, status: &quot;A&quot;, &#125;,</div><div class="line">     &#123; name: &quot;xi&quot;, age: 34, status: &quot;D&quot;, &#125;</div><div class="line">   ]</div><div class="line">)</div></pre></td></tr></table></figure><p>例子同前。</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>MongoDB 查询数据的语法格式如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db<span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.find</span>(&lt;query <span class="attribute">filter</span>&gt;, &lt;projection&gt;)</div></pre></td></tr></table></figure><p>第一个大括号为filter，第二个为投影，即你想显示的值。</p><p>find() 方法以非结构化的方式来显示所有文档。</p><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="selector-tag">db</span><span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.find</span>()<span class="selector-class">.pretty</span>()</div></pre></td></tr></table></figure><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="selector-tag">db</span><span class="selector-class">.users</span><span class="selector-class">.find</span>( &#123; <span class="attribute">status</span>: <span class="string">"A"</span> &#125; )</div><div class="line"></div><div class="line">&gt;<span class="selector-tag">db</span><span class="selector-class">.users</span><span class="selector-class">.find</span>( &#123; <span class="attribute">status</span>: <span class="string">"A"</span>, age: &#123; $lt: <span class="number">30</span> &#125; &#125; )</div></pre></td></tr></table></figure><p>上面四个例子中，第一个查询字段status的值为”A”的文档，第二个查询status的值为”A”,且age的值小于30的文档。</p><p>下表是一一些比较操作的示例：</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">格式格式</th><th style="text-align:left">范例</th><th style="text-align:left">RDBMS类似语句</th></tr></thead><tbody><tr><td style="text-align:left">等于</td><td style="text-align:left">{<key>:<value>}</value></key></td><td style="text-align:left">db.col.find({“name”:”mon”})</td><td style="text-align:left">where name = “mon”</td></tr><tr><td style="text-align:left">小于</td><td style="text-align:left">{<key>:{$lt:<value>}}</value></key></td><td style="text-align:left">db.col.find({“count”:{$lt:50}})</td><td style="text-align:left">where count &lt; 50</td></tr><tr><td style="text-align:left">小于或等于</td><td style="text-align:left">{<key>:{$lte:<value>}}</value></key></td><td style="text-align:left">db.col.find({“count”:{$lte:50}})</td><td style="text-align:left">where count &lt;= 50</td></tr><tr><td style="text-align:left">大于</td><td style="text-align:left">{<key>:{$gt:<value>}}</value></key></td><td style="text-align:left">db.col.find({“count”:{$gt:50}})</td><td style="text-align:left">where count&gt; 50</td></tr><tr><td style="text-align:left">大于或等于</td><td style="text-align:left">{<key>:{$gte:<value>}}</value></key></td><td style="text-align:left">db.col.find({“count”:{$gte:50}})</td><td style="text-align:left">where count &gt;= 50</td></tr><tr><td style="text-align:left">不等于</td><td style="text-align:left">{<key>:{$ne:<value>}}</value></key></td><td style="text-align:left">db.col.find({“count”:{$ne:50}})</td><td style="text-align:left">where count != 50</td></tr></tbody></table><h4 id="返回指定键"><a href="#返回指定键" class="headerlink" title="返回指定键"></a>返回指定键</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db<span class="selector-class">.user</span><span class="selector-class">.find</span>(&#123;&#125;, &#123;<span class="string">"name"</span> : <span class="number">1</span>, <span class="string">"_id"</span> : <span class="number">0</span>&#125;)</div></pre></td></tr></table></figure><p>第二个大括号，我们可以对find结果显示的值进行限定，设为1表示显示，0表示不显示，<code>_id</code>默认显示。如果要将<code>id</code>屏蔽，需显示设置 <code>_id</code>为0。</p><h4 id="多条件"><a href="#多条件" class="headerlink" title="多条件"></a>多条件</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.users</span><span class="selector-class">.find</span>(</div><div class="line">  &#123;</div><div class="line">    <span class="attribute">status</span>: <span class="string">"A"</span>,</div><div class="line">    $or: [ &#123; age: &#123; $lt: <span class="number">30</span> &#125; &#125;, &#123; <span class="attribute">type</span>: <span class="number">1</span> &#125; ]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><code>$or</code>表示条件数组中的条件只要有一个符合就进行显示。<code>$or</code>其后的条件数组中，其字段的设置。</p><h4 id="查询一个条件的多个值"><a href="#查询一个条件的多个值" class="headerlink" title="查询一个条件的多个值"></a>查询一个条件的多个值</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="builtin-name">find</span>(&#123;<span class="string">"num"</span> : &#123;<span class="string">"<span class="variable">$in</span>"</span> : [12, 13, 23]&#125;&#125;)</div></pre></td></tr></table></figure><p>如果要对同一条件的多个值进行过滤，可以使用<code>$in</code>。与之相对的是<code>$nin</code>。</p><h4 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="builtin-name">find</span>(&#123;<span class="string">"num"</span> : &#123;<span class="string">"<span class="variable">$not</span>"</span> : [12, 13]&#125;)</div></pre></td></tr></table></figure><p>当要选取的元素比较多时我们可以使用<code>$not</code>，它会使不在数组中的值的文档被选中。</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><strong>db.collection.update()</strong>: 第一个参数为过滤条件，第二个为upsert选项，第三个为是否更新多个文档。</p><h4 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.people.update(&#123;"_id": 1&#125;,&#123;"$set" : &#123;"name": "yang"&#125;)</div></pre></td></tr></table></figure><p>上面的例子中，第一个大括号为filter，第二个为进行的改动。</p><p>下面插入一条数据，然后对它进行改动：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.users</span><span class="selector-class">.insert</span>(</div><div class="line"> &#123;</div><div class="line">    <span class="attribute">_id</span>: <span class="number">1</span>,</div><div class="line">    <span class="attribute">name</span>: <span class="string">"sue"</span>,</div><div class="line">    <span class="attribute">age</span>: <span class="number">19</span>,</div><div class="line">    <span class="attribute">type</span>: <span class="number">1</span>,</div><div class="line">    <span class="attribute">status</span>: <span class="string">"P"</span>,</div><div class="line">    <span class="attribute">favorites</span>: &#123; <span class="attribute">artist</span>: <span class="string">"Picasso"</span>, <span class="attribute">food</span>: <span class="string">"pizza"</span> &#125;,</div><div class="line">    <span class="attribute">finished</span>: [ <span class="number">17</span>, <span class="number">3</span> ],</div><div class="line">    <span class="attribute">badges</span>: [ <span class="string">"blue"</span>, <span class="string">"black"</span> ],</div><div class="line">    <span class="attribute">points</span>: [</div><div class="line">        &#123; <span class="attribute">points</span>: <span class="number">85</span>, <span class="attribute">bonus</span>: <span class="number">20</span> &#125;,</div><div class="line">        &#123; <span class="attribute">points</span>: <span class="number">85</span>, <span class="attribute">bonus</span>: <span class="number">10</span> &#125;</div><div class="line">     ]</div><div class="line"> &#125;</div><div class="line">)</div></pre></td></tr></table></figure><h4 id="修改内嵌文档"><a href="#修改内嵌文档" class="headerlink" title="修改内嵌文档"></a>修改内嵌文档</h4><p>使用<code>$set</code>修改器进行，可直接通过<code>.</code>进行元素的访问</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.users.<span class="keyword">update</span>(</div><div class="line">   &#123; <span class="string">"favorites.artist"</span>: <span class="string">"Pisanello"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     $set: &#123; <span class="string">"favorites.food"</span>: <span class="string">"pizza"</span>&#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p> 错误的情况：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.users.<span class="keyword">update</span>(</div><div class="line">   &#123; <span class="string">"favorites.artist"</span>: <span class="string">"Pisanello"</span> &#125;,</div><div class="line">   &#123;</div><div class="line">     &#123; <span class="string">"favorites.food"</span>: <span class="string">"pizza"</span>&#125;</div><div class="line">   &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>不使用<code>$set</code>修改器，其意义为进行文档替换，结果就是原来的其他元素都没了，只剩下<code>{ &quot;favorites.food&quot;: &quot;pizza&quot;}</code>.</p><p> <code>$set</code>不仅可以对字段的值进行更改，同时也可以对类型进行修改。</p><p><code>$unset</code>可以将某个不需要的值尽行删除。</p><h4 id="数字增加或减少"><a href="#数字增加或减少" class="headerlink" title="数字增加或减少"></a>数字增加或减少</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span> : <span class="number">1</span>&#125;, &#123;<span class="string">"$inc"</span> : &#123;<span class="string">"article"</span> : <span class="number">1</span>&#125;&#125;)</div></pre></td></tr></table></figure><p><code>$inc</code>表示对该字段加上某一个值，该值由文档中的字段的值决定，值为负数时可进行减法。记住，该字段必须为数字。</p><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db<span class="selector-class">.comment</span><span class="selector-class">.update</span>(&#123;<span class="string">"_id"</span> : <span class="number">1</span>&#125;, &#123;<span class="string">"$push"</span> : &#123;<span class="string">"comments"</span> : <span class="string">"first"</span>&#125;)</div></pre></td></tr></table></figure><p><code>$push</code>表示在数组已有元素的末尾插入一个值。</p><h5 id="添加多个"><a href="#添加多个" class="headerlink" title="添加多个"></a>添加多个</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.blog.post.<span class="keyword">update</span>(&#123;<span class="string">"title"</span> : <span class="string">"Post"</span>&#125;, &#123;<span class="string">"$push"</span> : &#123;<span class="string">"tag"</span> : &#123;<span class="string">"$each"</span> : [<span class="string">"go"</span>, <span class="string">"linux"</span>, <span class="string">"database"</span>]&#125;&#125;&#125;)</div></pre></td></tr></table></figure><p><code>$push</code>和<code>$each</code>结合使用可以将一个数组中的多个值添加到指定字段.</p><h5 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db<span class="selector-class">.user</span><span class="selector-class">.update</span>(&#123;<span class="string">"_id"</span> : <span class="number">1</span>&#125;, &#123;<span class="string">"$addToSet"</span> : &#123;<span class="string">"emails"</span> : <span class="string">"23132132132@qq.com"</span>&#125;)</div></pre></td></tr></table></figure><p><code>$addToSet</code> 可以避免重复插入，当数组中已经有要添加的值时，该语句相当于不执行。</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>对于数组的删除，有两种不同方法。</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db<span class="selector-class">.comment</span><span class="selector-class">.update</span>(&#123;<span class="string">"_id"</span> : <span class="number">1</span>&#125;, &#123;<span class="string">"$pop"</span> : &#123;<span class="string">"comments"</span> : <span class="number">1</span>&#125;)</div></pre></td></tr></table></figure><p><code>$pop</code>表示从数组末尾删除几个元素，若为负数，表示从头删除。</p><h6 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db<span class="selector-class">.comment</span><span class="selector-class">.update</span>(&#123;&#125;, &#123;<span class="string">"$pull"</span> : &#123;<span class="string">"comments"</span> : <span class="string">"xxxx"</span>&#125;)</div></pre></td></tr></table></figure><p>与<code>$pop</code>根据元素位置删除元素不同，<code>$pull</code>依据条件删除元素。</p><h5 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="keyword">update</span>(&#123;<span class="string">"article"</span> : <span class="string">"post"</span>&#125;, &#123;<span class="string">"$inc"</span> : &#123;<span class="string">"comments.0.votes"</span> : <span class="number">1</span>&#125;&#125;)</div></pre></td></tr></table></figure><p>对于数组元素，我们也可以根据下标进行访问。</p><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="keyword">update</span>(&#123;<span class="string">"article"</span> : <span class="string">"post"</span>&#125;, &#123;<span class="string">"$set"</span> : &#123;<span class="string">"comments.$.author"</span> : <span class="string">"Jim"</span>&#125;&#125;)</div></pre></td></tr></table></figure><p>有些时候，我们不知道元素在数组中的下标，但经过前面filter的过滤，可以确定该元素，可以使用<code>$</code> 占位符，它就替代了前面filter所得到的元素。</p><h4 id="upsert"><a href="#upsert" class="headerlink" title="upsert"></a>upsert</h4><p>如果 <code>db.collection.update()</code>，<code>db.collection.updateOne()</code>， <code>db.collection.updateMany()</code> 或者 <code>db.collection.replaceOne()</code>包含 <code>upsert : true</code>  <strong>并且</strong>没有文档匹配指定的过滤器，那么此操作会创建一个新文档并插入它。如果有匹配的文档，那么此操作修改或替换匹配的单个或多个文档。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.<span class="keyword">update</span>(&#123;<span class="string">"rep"</span> : <span class="number">25</span>&#125;, &#123;<span class="string">"$inc"</span> : &#123;<span class="string">"rep"</span> : <span class="number">3</span>&#125;&#125;, <span class="literal">true</span>)</div></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.user</span><span class="selector-class">.remove</span>(&#123;&#125;)</div></pre></td></tr></table></figure><p>简单示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.users</span><span class="selector-class">.remove</span>( &#123; <span class="attribute">status </span>: false &#125;, 1)</div></pre></td></tr></table></figure><p>当然还有delete方法也可以删除文档：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.deleteOne</span>(&#123; <span class="attribute">status</span>: <span class="string">"D"</span> &#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://yangchenglong11.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="https://yangchenglong11.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Golang 实现大数的乘法</title>
    <link href="https://yangchenglong11.github.io/2016/11/21/Golang-%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>https://yangchenglong11.github.io/2016/11/21/Golang-实现大数乘法/</id>
    <published>2016-11-21T08:24:15.000Z</published>
    <updated>2017-10-03T12:08:34.890Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Go 语言实现两个大数的乘法。<br><a id="more"></a></p><p>看到一道题目，要求模拟小学生的运算思维，实现大数的乘法。觉得不错就动手做了下，不过真正做的时候并没有完全按照小学生的思维，稍稍优化了些。</p><p>大体思路就是用字符串来表示大数，将他们存到数组中，结果也存到数组中，这样就解决了因数字太大导致计算机无法表示的问题。</p><p>可以发现，在两个数进行运算时，积最多为 m+n 位，而且第一个乘数的第 m 位与第二个乘数的第 n 位的结果应在结果的第 m+n 位。有了思路。就开始编码吧！下面附上代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"bufio"</span></div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"os"</span></div><div class="line"><span class="string">"strconv"</span></div><div class="line"><span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutl</span><span class="params">(a, b <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">num_a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>)</div><div class="line">str_a := strings.Split(a, <span class="string">""</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str_a)<span class="number">-1</span>; i++ &#123;</div><div class="line">num_a[i], _ = strconv.Atoi(str_a[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">num_b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>)</div><div class="line">str_b := strings.Split(b, <span class="string">""</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str_b)<span class="number">-1</span>; i++ &#123;</div><div class="line">num_b[i], _ = strconv.Atoi(str_b[i])</div><div class="line">&#125;</div><div class="line"></div><div class="line">total := <span class="built_in">len</span>(num_a) + <span class="built_in">len</span>(num_b)</div><div class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, total)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">index1   = <span class="number">0</span></div><div class="line">index2   = <span class="number">0</span></div><div class="line">resIndex = <span class="number">0</span></div><div class="line">segRes   = <span class="number">0</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(num_a); i &gt; <span class="number">0</span>; i-- &#123;</div><div class="line">index1 = <span class="built_in">len</span>(num_a) - i</div><div class="line"></div><div class="line"><span class="keyword">for</span> j := <span class="built_in">len</span>(num_b); j &gt; <span class="number">0</span>; j-- &#123;</div><div class="line">index2 = <span class="built_in">len</span>(num_b) - j</div><div class="line"></div><div class="line">resIndex = index1 + index2</div><div class="line">segRes = num_a[index1] * num_b[index2]</div><div class="line"></div><div class="line">carry(&amp;result, resIndex, segRes)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fmt.Print(<span class="string">"结果为："</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total<span class="number">-1</span>; i++ &#123;</div><div class="line">fmt.Print(result[i])</div><div class="line">&#125;</div><div class="line">fmt.Println()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">carry</span><span class="params">(arr *[]<span class="keyword">int</span>, index <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">(*arr)[index] += value</div><div class="line"></div><div class="line"><span class="keyword">if</span> (*arr)[index] &gt; <span class="number">9</span> &#123;</div><div class="line">result := (*arr)[index] / <span class="number">10</span></div><div class="line">(*arr)[index] = (*arr)[index] % <span class="number">10</span></div><div class="line">carry(arr, index<span class="number">-1</span>, result)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">aa := bufio.NewReader(os.Stdin)</div><div class="line">fmt.Print(<span class="string">"请输入一个乘数: "</span>)</div><div class="line">a, _ := aa.ReadString(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">bb := bufio.NewReader(os.Stdin)</div><div class="line">fmt.Print(<span class="string">"请输入另一个乘数: "</span>)</div><div class="line">b, _ := bb.ReadString(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">mutl(a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用 Go 语言实现两个大数的乘法。&lt;br&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>go并发编程基础</title>
    <link href="https://yangchenglong11.github.io/2016/11/19/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://yangchenglong11.github.io/2016/11/19/go并发编程基础/</id>
    <published>2016-11-19T08:24:15.000Z</published>
    <updated>2017-10-03T12:17:43.581Z</updated>
    
    <content type="html"><![CDATA[<p>并发其主要思想是使多个任务可以在同一时间执行以便能够更快的得到结果。并发编程的思想来自于多任务操作系统。</p><a id="more"></a><p>多任务操作系统允许同时运行多个程序。与之相对的是单用户计算机系统的操作系统，任务是被一个接一个的读取，寻找资源并运行的，各任务的运行完全是串行的。</p><p>并发程序内部会被划分为多个部分，每个部分都可以被看作是一个串行程序，在这些串行程序之间可能会存在交互的需求，这就需要操作系统去协调。在这之前，我们先来看下进程。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>我们通常把一个程序的执行称为一个进程，同时进程也被用来描述程序的执行过程。</p><p>一个进程可以使用系统调用fork创建若干新的进程。前者被称为后者的父进程，每一个进程都有父进程。所有的进程共同组成了一个树状结构，内核启动进程作为进程树的根并负责系统的初始化操作。它的父进程就是它自己。</p><p>为了管理进程，内核必须对每个进程的属性，行为进行详细的记录，包括进程的优先级，状态，虚拟地址范围以及各种访问权限等等。这些信息都会被记录在每个进程的进程描述符中，而被保存在进程描述符中的进程ID(常叫做PID)是进程在操作系统中的唯一标识，同时进程描述符中还会包含当前进程的父进程的ID(常被称为PPID)。</p><p>进程的状态共有6个，分别是可运行状态，可中断的睡眠状态，不可中断的睡眠状态，暂停状态或跟踪状态，僵尸状态和退出状态。</p><p>linux操作系统可以凭借cpu快速在多个进程之间切换，以产生多个进程在同时运行的假象。但切换正在运行的进程是需要付出代价的。</p><p>内核对进程的合理切换和调度使多个进程可以有条不紊的并发执行，在很多时候，多个进程之间需要相互配合并合作完成一个任务，这就需要进程间通讯机制(IPC)的支持。下面就讲一下go语言支持的IPC方法。它们是管道，信号和Socket。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道(pipe)是一种是单向的通讯方式。它只能被用于父进程与子进程以及同祖先的子进程之间的通讯。例如，我们在使用shell命令的时候常常会用到管道：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bogon:~ yang$ <span class="keyword">ps</span> aux | <span class="keyword">grep</span> <span class="keyword">go</span></div></pre></td></tr></table></figure><p>shell命令为每个命令都创建一个进程，然后把左边的命令的标准输出用管道与右边的命令的标准输入连接起来。</p><p>管道的优点在于它的简单，而缺点则是只能单向通讯以及对通讯双方关系上的严格限制。</p><p>对于管道，go语言是支持的。通过标准库代码包os/exec中的API，我们可以执行操作系统命令并在此基础上建立管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"bufio"</span></div><div class="line"><span class="string">"bytes"</span></div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"io"</span></div><div class="line"><span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">demo1()</div><div class="line">fmt.Println()</div><div class="line">demo2()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</div><div class="line">fmt.Println(<span class="string">"Run command `ps aux | grep apipe`: "</span>)</div><div class="line">cmd1 := exec.Command(<span class="string">"ps"</span>, <span class="string">"aux"</span>)</div><div class="line">cmd2 := exec.Command(<span class="string">"grep"</span>, <span class="string">"apipe"</span>)</div><div class="line">stdout1, err := cmd1.StdoutPipe()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not obtain the stdout pipe for command: %s"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> err := cmd1.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: The command can not running: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//使用带缓冲的读取器可以非常方便和灵活的读取需要的内容，而不是只能先把所有内容读出来再作处理</span></div><div class="line">outputBuf1 := bufio.NewReader(stdout1)</div><div class="line">        <span class="comment">//StdinPipe方法返回一个在命令Start后与命令标准输入关联的管道</span></div><div class="line">stdin2, err := cmd2.StdinPipe()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not obtain the stdin pipe for command: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//WriteTo把所属值中缓存的数据全部写入到参数值代表的写入器中</span></div><div class="line">outputBuf1.WriteTo(stdin2)</div><div class="line"><span class="keyword">var</span> outputBuf2 bytes.Buffer</div><div class="line">cmd2.Stdout = &amp;outputBuf2</div><div class="line"><span class="keyword">if</span> err := cmd2.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: The command can not be startup: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">err = stdin2.Close()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not close the stdio pipe: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//wait会一直阻塞到所属命令完全运行结束为止</span></div><div class="line"><span class="keyword">if</span> err := cmd2.Wait(); err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not wait for the command: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, outputBuf2.Bytes())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</div><div class="line">useBufferIo := <span class="literal">false</span></div><div class="line">fmt.Println(<span class="string">"Run command `echo -n \"My first command from golang.\"`: "</span>)</div><div class="line">cmd0 := exec.Command(<span class="string">"echo"</span>, <span class="string">"-n"</span>, <span class="string">"My first command from golang."</span>)</div><div class="line"><span class="comment">//创建一个能获取此命令输出的管道</span></div><div class="line">stdout0, err := cmd0.StdoutPipe()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not obtain the stdout pipe for command No.0: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> err := cmd0.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: The command No.0 can not be startup: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> !useBufferIo &#123;</div><div class="line"><span class="keyword">var</span> outputBuf0 bytes.Buffer</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">tempOutput := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</div><div class="line"><span class="comment">//Read把读出的数据存入调用方传递给他的字节切片</span></div><div class="line">n, err := stdout0.Read(tempOutput)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">if</span> err == io.EOF &#123;</div><div class="line"><span class="keyword">break</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not read data from the pipe: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</div><div class="line">outputBuf0.Write(tempOutput[:n])</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, outputBuf0.String())</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">outputBuf0 := bufio.NewReader(stdout0)</div><div class="line">output0, _, err := outputBuf0.ReadLine()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not read data from the pipe: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(output0))</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面我们讲的是匿名管道，与之相对的是命名管道。与匿名管道不同，任何进程都可以通过命名管道交换数据。实际上，命名管道以文件的形式存在于文件系统中，使用它的方法与使用文件类似，linux支持使用shell命令创建和使用命名管道，例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bogon:<span class="keyword">test</span> yang$ mkfifo -<span class="keyword">m</span> 644 myfifo2</div><div class="line">bogon:<span class="keyword">test</span> yang$ tee of_login &lt; myfifo2 &amp;</div><div class="line">[1] 10028</div><div class="line">bogon:<span class="keyword">test</span> yang$ vi tepipi.txt</div><div class="line">bogon:<span class="keyword">test</span> yang$ <span class="keyword">cat</span> tepipi.txt &gt;myfifo2</div><div class="line">[1]+  Done                    tee of_login &lt; myfifo2</div></pre></td></tr></table></figure><p>在上面的实例中，我们先使用命令mkfifo在当前目录创建了一个命名管道mififo2，然后又使用这个命名管道和命名tee把tepipe.txt文件中的内容写到了of_login文件中。</p><p>这里只是使用了命名管道搬运了数据，我们也可以在此基础上实现诸如数据的过滤或转换，以及管道的多路复用等功能。注意，命名管道默认是阻塞式的，更具体的说，只有在对这个命令管道的读操作和写操作都已准备就绪后，数据才会流转。它相对于匿名管道的优势就是通讯双方可以毫不相关。但命名管道也是单向的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"io"</span></div><div class="line"><span class="string">"os"</span></div><div class="line"><span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">fileBasedPipe()</div><div class="line">inMemorySyncPipe()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileBasedPipe</span><span class="params">()</span></span> &#123;</div><div class="line">reader, writer, err := os.Pipe()</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not create the named pipe: %s\n"</span>, err)</div><div class="line">&#125;</div><div class="line"><span class="comment">//命名管道默认会在其中一端还未就绪时阻塞另一端的进程</span></div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">output := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</div><div class="line">n, err := reader.Read(output)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not read data from the named pipe: %s\n"</span>, err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Read %d byte(s). [file-based pipe]\n"</span>, n)</div><div class="line">&#125;()</div><div class="line">input := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">26</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">65</span>; i &lt;= <span class="number">90</span>; i++ &#123;</div><div class="line">input[i<span class="number">-65</span>] = <span class="keyword">byte</span>(i)</div><div class="line">&#125;</div><div class="line">n, err := writer.Write(input)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not write data to the named pipe: %s\n"</span>, err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Written %d byte(s). [file-based pipe]\n"</span>, n)</div><div class="line">time.Sleep(<span class="number">200</span> * time.Millisecond)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">inMemorySyncPipe</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">//与上面的两个命名管道不同，这两个是被存于内存中的，有原子性操作保证的管道</span></div><div class="line">reader, writer := io.Pipe()</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">output := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</div><div class="line">n, err := reader.Read(output)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not read data from the named pipe: %s\n"</span>, err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Read %d byte(s). [in-memory pipe]\n"</span>, n)</div><div class="line">&#125;()</div><div class="line">input := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">26</span>)</div><div class="line"><span class="keyword">for</span> i := <span class="number">65</span>; i &lt;= <span class="number">90</span>; i++ &#123;</div><div class="line">input[i<span class="number">-65</span>] = <span class="keyword">byte</span>(i)</div><div class="line">&#125;</div><div class="line">n, err := writer.Write(input)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Error: Can not write data to the named pipe: %s\n"</span>, err)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Written %d byte(s). [in-memory pipe]\n"</span>, n)</div><div class="line">time.Sleep(<span class="number">200</span> * time.Millisecond)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>它是IPC中唯一一种异步的通讯方法。它的本质是利用软件来模拟硬件的中断机制。信号被用来通知某个进程有某个事件发生了。使用kill命令查看当前系统支持的信号。</p><p>linux支持的信号有62种，分别分为两大类，1到31号为标准信号，也叫不可靠信号，34到64为实时信号，也叫可靠信号。</p><p>对同一进程来说，每种标准信号只会被记录并处理一次，并且如果某一进程的标准信号种类有好多，其处理顺序也是完全不确定的。而实时信号正好相反，即同种类的多个信号都可以被记录，并且可以按照发送的顺序被处理。</p><p>进程响应信号的方式有3种：忽略，捕捉和执行默认操作 .</p><p>linux对每个标准信号都有默认的操作方式。对大多数标准信号，我们可以自定义当进程接收到他们之后进行怎样的处理。在程序中，这些作为信号响应的自定义操作往往是由函数来代表的。</p><p>go命令会对其中的一些以键盘输入为来源的标准信号作出相应。这是由于go命令使用了在标准库代码包os/signal 中的被用于处理信号的API。</p><p>下面我们看下os.Signal接口类型的声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Signal <span class="keyword">interface</span> &#123;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">  Signal() <span class="comment">// to distinguish from other Stringers</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从声明可知，其中的Signal()方法的声明并没有实际意义。它只是作为os.Signal接口类型的一个标识。</p><p>在标准库代码包syscall中，已经为不同的操作系统的所支持的每一个标准信号都声明了一个同名常量，其类型都为syscall.Signal——os.Signal接口类型的一个实现类型，同时也是一个int类型的别名类型。每个信号常量的整数值与他所代表的信号在操作系统中的编号一致。</p><p>代码包os/signal 中的Notify函数用来把操作系统发给当前进程的指定信号通知给该函数的调用方。声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Notify</span><span class="params">(c <span class="keyword">chan</span>&lt;- os.Signal, sig ...os.Signal)</span></span></div></pre></td></tr></table></figure><p>signal处理程序在向接受通道发送值的时候，并不会因为通道已满而产生阻塞。</p><p>前面说过，大部分的标准信号我们都可以自定义其处理方法，不过有两种信号除外。SIGKILL和SIGSTOP。对他们的响应只执行系统默认操作。</p><p>对于其他信号，我们可以自行处理也可以恢复对他们的系统默认操作，这需要使用到os/signal包中的Stop函数。声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stop</span><span class="params">(c <span class="keyword">chan</span>&lt;- os.Signal)</span></span></div></pre></td></tr></table></figure><p>只需将Notify中的输入通道作为参数传入即可取消对这些信号的自行处理。</p><p>当然，我们也可以只对部分信号取消自定义处理，这时可以重新调用Notify函数，只需要第一个参数相同即可。</p><p>下面通过一个程序来实现以下功能：</p><p>1.执行一系列操作系统命令并获取演示进程的进程ID；</p><p>2.使用该进程值之上的API相对应的进程发送一个SIGINT信号，并输出演示进程已受到信号的凭证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"bytes"</span></div><div class="line"><span class="string">"errors"</span></div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"io"</span></div><div class="line"><span class="string">"os"</span></div><div class="line"><span class="string">"os/exec"</span></div><div class="line"><span class="string">"os/signal"</span></div><div class="line"><span class="string">"runtime/debug"</span></div><div class="line"><span class="string">"strconv"</span></div><div class="line"><span class="string">"strings"</span></div><div class="line"><span class="string">"sync"</span></div><div class="line"><span class="string">"syscall"</span></div><div class="line"><span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">time.Sleep(<span class="number">5</span> * time.Second)</div><div class="line">sigSendingDemo()</div><div class="line">&#125;()</div><div class="line">sigHandleDemo()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sigHandleDemo</span><span class="params">()</span></span> &#123;</div><div class="line">sigRecv1 := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</div><div class="line">sigs1 := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;</div><div class="line">fmt.Printf(<span class="string">"Set notification for %s... [sigRecv1]\n"</span>, sigs1)</div><div class="line">signal.Notify(sigRecv1, sigs1...)</div><div class="line">sigRecv2 := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</div><div class="line">sigs2 := []os.Signal&#123;syscall.SIGQUIT&#125;</div><div class="line">fmt.Printf(<span class="string">"Set notification for %s... [sigRecv2]\n"</span>, sigs2)</div><div class="line">signal.Notify(sigRecv2, sigs2...)</div><div class="line"></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">wg.Add(<span class="number">2</span>)</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">//在sigRecv通道被关闭后，for语句会立即被退出执行</span></div><div class="line"><span class="keyword">for</span> sig := <span class="keyword">range</span> sigRecv1 &#123;</div><div class="line">fmt.Printf(<span class="string">"Received a signal from sigRecv1: %s\n"</span>, sig)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"End. [sigRecv1]\n"</span>)</div><div class="line">wg.Done()</div><div class="line">&#125;()</div><div class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">for</span> sig := <span class="keyword">range</span> sigRecv2 &#123;</div><div class="line">fmt.Printf(<span class="string">"Received a signal from sigRecv2: %s\n"</span>, sig)</div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"End. [sigRecv2]\n"</span>)</div><div class="line">wg.Done()</div><div class="line">&#125;()</div><div class="line"></div><div class="line">fmt.Println(<span class="string">"Wait for 3 seconds... "</span>)</div><div class="line">time.Sleep(<span class="number">3</span> * time.Second)</div><div class="line">fmt.Printf(<span class="string">"Stop notification..."</span>)</div><div class="line">signal.Stop(sigRecv1)</div><div class="line"><span class="built_in">close</span>(sigRecv1)</div><div class="line">fmt.Printf(<span class="string">"done. [sigRecv1]\n"</span>)</div><div class="line">wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sigSendingDemo</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Fatal Error: %s\n"</span>, err)</div><div class="line">debug.PrintStack()</div><div class="line">&#125;</div><div class="line">&#125;()</div><div class="line"><span class="comment">// ps aux | grep "mysignal" | grep -v "grep" | grep -v "go run" | awk '&#123;print $2&#125;'</span></div><div class="line">cmds := []*exec.Cmd&#123;</div><div class="line">exec.Command(<span class="string">"ps"</span>, <span class="string">"aux"</span>),</div><div class="line">exec.Command(<span class="string">"grep"</span>, <span class="string">"mysignal"</span>),</div><div class="line">exec.Command(<span class="string">"grep"</span>, <span class="string">"-v"</span>, <span class="string">"grep"</span>),</div><div class="line">exec.Command(<span class="string">"grep"</span>, <span class="string">"-v"</span>, <span class="string">"go run"</span>),</div><div class="line">exec.Command(<span class="string">"awk"</span>, <span class="string">"&#123;print $2&#125;"</span>),</div><div class="line">&#125;</div><div class="line">output, err := runCmds(cmds)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Command Execution Error: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">pids, err := getPids(output)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"PID Parsing Error: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">fmt.Printf(<span class="string">"Target PID(s):\n%v\n"</span>, pids)</div><div class="line"><span class="keyword">for</span> _, pid := <span class="keyword">range</span> pids &#123;</div><div class="line">proc, err := os.FindProcess(pid)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Process Finding Error: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">sig := syscall.SIGQUIT</div><div class="line">fmt.Printf(<span class="string">"Send signal '%s' to the process (pid=%d)...\n"</span>, sig, pid)</div><div class="line">err = proc.Signal(sig)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Signal Sending Error: %s\n"</span>, err)</div><div class="line"><span class="keyword">return</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPids</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span> &#123;</div><div class="line">pids := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</div><div class="line">pid, err := strconv.Atoi(strings.TrimSpace(str))</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line">pids = <span class="built_in">append</span>(pids, pid)</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> pids, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmds</span><span class="params">(cmds []*exec.Cmd)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> &#123;</div><div class="line"><span class="keyword">if</span> cmds == <span class="literal">nil</span> || <span class="built_in">len</span>(cmds) == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"The cmd slice is invalid!"</span>)</div><div class="line">&#125;</div><div class="line">first := <span class="literal">true</span></div><div class="line"><span class="keyword">var</span> output []<span class="keyword">byte</span></div><div class="line"><span class="keyword">var</span> err error</div><div class="line"><span class="keyword">for</span> _, cmd := <span class="keyword">range</span> cmds &#123;</div><div class="line">fmt.Printf(<span class="string">"Run command: %v ...\n"</span>, getCmdPlaintext(cmd))</div><div class="line"><span class="keyword">if</span> !first &#123;</div><div class="line"><span class="keyword">var</span> stdinBuf bytes.Buffer</div><div class="line">stdinBuf.Write(output)</div><div class="line">cmd.Stdin = &amp;stdinBuf</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stdoutBuf bytes.Buffer</div><div class="line">cmd.Stdout = &amp;stdoutBuf</div><div class="line"><span class="keyword">if</span> err = cmd.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, getError(err, cmd)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> err = cmd.Wait(); err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, getError(err, cmd)</div><div class="line">&#125;</div><div class="line">output = stdoutBuf.Bytes()</div><div class="line"><span class="comment">//fmt.Printf("Output:\n%s\n", string(output))</span></div><div class="line"><span class="keyword">if</span> first &#123;</div><div class="line">first = <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">lines := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line"><span class="keyword">var</span> outputBuf bytes.Buffer</div><div class="line">outputBuf.Write(output)</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">line, err := outputBuf.ReadBytes(<span class="string">'\n'</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">if</span> err == io.EOF &#123;</div><div class="line"><span class="keyword">break</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>, getError(err, <span class="literal">nil</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">lines = <span class="built_in">append</span>(lines, <span class="keyword">string</span>(line))</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> lines, <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCmdPlaintext</span><span class="params">(cmd *exec.Cmd)</span> <span class="title">string</span></span> &#123;</div><div class="line"><span class="keyword">var</span> buf bytes.Buffer</div><div class="line">buf.WriteString(cmd.Path)</div><div class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> cmd.Args[<span class="number">1</span>:] &#123;</div><div class="line">buf.WriteRune(<span class="string">' '</span>)</div><div class="line">buf.WriteString(arg)</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> buf.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getError</span><span class="params">(err error, cmd *exec.Cmd, extraInfo ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line"><span class="keyword">var</span> errMsg <span class="keyword">string</span></div><div class="line"><span class="keyword">if</span> cmd != <span class="literal">nil</span> &#123;</div><div class="line">errMsg = fmt.Sprintf(<span class="string">"%s  [%s %v]"</span>, err, (*cmd).Path, (*cmd).Args)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">errMsg = fmt.Sprintf(<span class="string">"%s"</span>, err)</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(extraInfo) &gt; <span class="number">0</span> &#123;</div><div class="line">errMsg = fmt.Sprintf(<span class="string">"%s (%v)"</span>, errMsg, extraInfo)</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> errors.New(errMsg)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发其主要思想是使多个任务可以在同一时间执行以便能够更快的得到结果。并发编程的思想来自于多任务操作系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker是什么</title>
    <link href="https://yangchenglong11.github.io/2016/11/15/Docker%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://yangchenglong11.github.io/2016/11/15/Docker是什么/</id>
    <published>2016-11-15T04:10:10.000Z</published>
    <updated>2017-09-24T06:15:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单说它是一个开源的容器引擎，可以帮助开发者高效的构建应用。<br><a id="more"></a> </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437250607&auto=0&height=66"></iframe><p>我们先看一下正常情况，我们是怎样构建一个简单应用的呢？首先它要有一个基础的平台，也就是操作系统来让它运行，比如 win，linux 等等。然后我们就可以写代码来实现它。在这个过程中，我们可能会用到数据库，框架等等。为了在代码中使用这些，我们会根据需要进行相关的配置，或者下载所需的依赖。但这个过程有时并不是想象中的那么简单，甚至有些时候仅仅是配置环境就让一些开发者望而却步。等我们所有的工作都完成后，将它部署到服务器上提供服务，我们的应用就开发完了，接着就是无休止的运维了。</p><p>为了更好的理解 Docker 是什么？我们把上面构建应用的过程比作运输货物，我们把上面提到的操作系统看作是进行运输的交通工具，这里我们就把大鲸鱼当作交通工具吧，把交付的应用程序看成是各种货物，我们要将各种各样形状、尺寸不同的货物放到大鲸鱼上，我们需要为每件货物考虑怎么安放（就是应用程序配套的环境），还得考虑货物和货物是否能叠起来（应用程序依赖的环境是否会冲突）。这可不是一份简单的差事，有时候因为安排不当甚至会导致这一次运输的失败。但后来出现了集装箱，我们把每件货物都放到集装箱里，这样我们的就可以用同样地方式安放、堆叠集装了，省事省力。</p><p>上面提到的集装箱就是 Docker 中的“容器”，而 Docker 就是管理这些集装箱的一整套机制。集装箱好像只是做了一层封装，没有什么很神奇的地方。但我们继续想象下场景，集装箱出现之后，世界上绝大多数的货物运输都可以放到这个神奇的箱子里，然后在公路、铁路、海洋等所有运输场景下，这个箱子都不用变化形态直接可以承运，而且中间的中转工作，都可以通过大型机械搞定，效率大大提升，从此生产力飙升。因为集装箱规范了运输的标准，于是相应的船舶、卡车、列车以及自动化中转设备才能按照规格，被制造出来，然后使联运以及自动化成为可能，才可以极大的提高效率，提升自动化水平。集装箱本身是一个产品，而这个产品无非就是标准化的具体体现，现实世界中的事实显而易见，就是这么简单。</p><p>按照这个思路，Docker 其实跟集装箱一样，或者说它想跟集装箱一样，成为穿着马甲的“标准化”。这样开发工程师就可以把它们开发出来的 bug 们放到“集装箱”里，然后运维人员就可以使用标准化的操作工具去运维这些可爱的 bug 们。于是实现了“海陆联运”，就好像运维工程师根本不需要了解其运维的软件架构而开发工程师也并不需要了解其软件运行的操作系统一样…… 总的来说，Docker 的目的是实现自动化运维，自动化运维的大前提是标准化，而 Docker 就是实现标准化的工具。</p><p>然后我们具体看看它能给开发和运维带来哪些福利。</p><p>它可以让我们更快速的交付和部署应用。使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用相同环境来部署代码。Docker 可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，各个步骤都有明确的配置和操作，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p><p>它可以实现更高效的资源利用。Docker 容器的运行不需要额外的虚拟化管理程序支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。</p><p>它能帮我们更轻松的迁移和扩展。Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性让用户可以在不同平台之间轻松地迁移应用。同时 Docker 创造性的使用了类似 git 管理代码的方式对镜像进行管理，也方便我们进行获取和管理 Docker 镜像。</p><p>它可以帮助我们更简单进行更新管理。使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式进行分发和更新，从而实现自动化并且高效的容器管理。Dockerfile 就是你的文档，并且用来产生镜像。要改变 Docker 镜像中的环境，先改 Dockerfile，用它产生镜像就行了，保证文档和环境一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单说它是一个开源的容器引擎，可以帮助开发者高效的构建应用。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://yangchenglong11.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://yangchenglong11.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux中改变文件属性与权限</title>
    <link href="https://yangchenglong11.github.io/2016/11/13/Linux%E4%B8%AD%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9D%83%E9%99%90/"/>
    <id>https://yangchenglong11.github.io/2016/11/13/Linux中改变文件属性与权限/</id>
    <published>2016-11-13T11:52:46.000Z</published>
    <updated>2017-09-29T09:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章讲了在 Linux 中怎样改变文件的属性与权限。</p><a id="more"></a> <h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p><strong>chgrp改变文件所属用户组</strong></p><p>chgrp即为change group的简写，如果要改变文件的用户组，要被改变的用户组必须要在/etc/group文件中存在才行，否则就会显示错误，可以进入这个目录查看文件内容，但建议使用cat命令，不要使用vi/vim，因为一旦不慎修改了此文件，系统文件出错后果是很严重的。</p><p>改变之前：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ ls -al</div><div class="line">yangs-MacBook-Air:code yang$ -rw-r--r--   1 yang  staff    14 Jan 12 17:01 te1</div></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ chgrp everyone te1</div></pre></td></tr></table></figure><p>让我们查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ ls -al</div><div class="line">yangs-MacBook-Air:code yang$ -rw-r--r--   1 yang  everyone    14 Jan 12 17:04 te1</div></pre></td></tr></table></figure><p>可以看到已经被修改了。</p><p>当所改用户组未在文件中时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ chgrp eve te1</div><div class="line">chgrp: eve: illegal group name</div></pre></td></tr></table></figure><p>这个命令还有一个可选参数 -R,即进行递归(recursive)的持续更改，即连同子目录下的所有文件目录都更新成为这个用户组，常用在更改某一目录内所有的文件情况。</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><strong>chown改变文件所有者</strong></p><p>chown即为 change owner 的简写，同样的，所改变的用户也必须是在/etc/passwd这个文件中有记录的用户名才可以。</p><p>chown 也可以直接修改用户组的名称，如果要连目录内所有子目录和文件都同时修改的话，直接加上-R即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ chown bin te1</div><div class="line">// 下面这个是将 te1 的所有者与用户组都改为 root</div><div class="line">yangs-MacBook-Air:code yang$ chown root:root</div></pre></td></tr></table></figure><p>可能你会有疑问，上述两个命令有什么用呢？最常见的例子就是复制文件给你之外的其他人时，比如使用cp命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yangs-MacBook-Air:code yang$ cp 源文件 目标文件</div></pre></td></tr></table></figure><p>由于复制行为(cp)会复制执行者的属性与权限，那么对于其他人可能仍是无法修改此文件的。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><strong>chmod改变文件权限</strong></p><p>chmod 命令用来变更文件或目录的权限。</p><p>在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用 chmod 指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 </p><p>权限范围的表示法如下： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- u User，即文件或目录的拥有者；</div><div class="line">- g Group，即文件或目录的所属群组；</div><div class="line">- o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；</div><div class="line">- a All，即全部的用户，包含拥有者，所属群组以及其他用户；</div><div class="line">- r 读取权限，数字代号为“4”; w 写入权限，数字代号为“2”；</div><div class="line">- x 执行或切换权限，数字代号为“1”； - 不具任何权限，数字代号为“0”；</div><div class="line">- s 特殊功能说明：变更文件或目录的权限。</div></pre></td></tr></table></figure><p>语法 chmod (选项) (参数) </p><p>选项 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- -c或——changes：效果类似“-v”参数，但仅回报更改的部分；</div><div class="line">- -f或--quiet或——silent：不显示错误信息；</div><div class="line">- -R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；</div><div class="line">- -v或——verbose：显示指令执行过程；</div><div class="line">- --reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；</div><div class="line">- &lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置；</div><div class="line">- &lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置；</div><div class="line">- &lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置；</div></pre></td></tr></table></figure><p>参数 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- 权限模式：指定文件的权限模式； </div><div class="line">- 文件：要改变权限的文件。</div><div class="line">``` </div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">知识扩展: Linux 用户分为：拥有者、组群(Group)、其他（other），Linux 系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及 root 的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內。</div><div class="line"></div><div class="line">---</div><div class="line"></div><div class="line">例：rwx　rw-　r-- 　</div><div class="line"></div><div class="line">r 为读取属性　　  // 值＝4 </div><div class="line"></div><div class="line">w 为写入属性　　 // 值＝2 </div><div class="line"></div><div class="line">x 为执行属性　　  // 值＝1　</div><div class="line"></div><div class="line">```shell</div><div class="line">chmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限 </div><div class="line"></div><div class="line">chmod u=rwx,g=rw,o=r f01</div><div class="line"></div><div class="line">chmod 764 f01</div><div class="line"></div><div class="line">chmod a+x f01　　//对文件f01的u,g,o都设置可执行属性 文件的属主和属组属性设置 </div><div class="line"></div><div class="line">chown user:market f01　　//把文件f01给uesr，添加到market组 ll -d f1 查看目录f1的属性</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章讲了在 Linux 中怎样改变文件的属性与权限。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://yangchenglong11.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://yangchenglong11.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>set 高级功能</title>
    <link href="https://yangchenglong11.github.io/2016/10/28/set-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
    <id>https://yangchenglong11.github.io/2016/10/28/set-高级功能/</id>
    <published>2016-10-28T08:24:15.000Z</published>
    <updated>2017-10-03T11:51:38.460Z</updated>
    
    <content type="html"><![CDATA[<p>在集合代数中除了对集合基本性质和规律的描述外，还包含了对各种集合运算和集合关系的说明。集合的运算包括并集，交集，差集还有对称差集。集合的关系包括相等和真包含。这篇文章我们就来实现这些功能。</p><a id="more"></a><p>首先我们添加集合真包含的判断功能。根据集合代数中的描述，如果集合 A 真包含了集合 B，那么就可以说集合 A 是集合 B 的一个超集。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断集合 set 是否是集合 other 的超集 </span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">IsSuperset</span><span class="params">(other *HashSet)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> other == <span class="literal">nil</span> &#123;         <span class="comment">// 如果other为nil，则other不是set的子集</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  setLen := set.Len()       <span class="comment">// 获取set的元素值数量</span></div><div class="line">  otherLen := other.Len()   <span class="comment">// 获取other的元素值数量</span></div><div class="line">  <span class="keyword">if</span> setLen == <span class="number">0</span> || setLen == otherLen &#123;   <span class="comment">// set的元素值数量等于0或者等于other的元素数量</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> setLen &gt; <span class="number">0</span> &amp;&amp; otherLen == <span class="number">0</span> &#123;         <span class="comment">// other为元素数量为0，set元素数量大于0，则set也是other的超集</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> other.Elements() &#123;</div><div class="line">    <span class="keyword">if</span> !set.Contains(v) &#123;                  <span class="comment">// 只要set中有一个other中的数据不在其中，就返回false</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>集合的运算包括<strong>并集、交集、差集</strong>和<strong>对称差集</strong>。 </p><p><strong>并集运算</strong>是指把两个集合中的所有元素都合并起来并组合成一个集合。 </p><p><strong>交集运算</strong>是指找到两个集合中共有的元素并把它们组成一个集合。 </p><p><strong>集合 A</strong> 对<strong>集合 B </strong>进行<strong>差集运算</strong>的含义是找到只存在于<strong>集合 A</strong> 中但不存在于<strong>集合 B</strong> 中的元素并把它们组成一个集合。 </p><p>对称差集运算与差集运算类似但有所区别。对称差集运算是指找到只存在于<strong>集合 A</strong> 中但不存在于<strong>集合 B</strong> 中的元素，再找到只存在于集合 B 中但不存在于集合 A 中的元素，最后把它们合并起来并组成一个集合。</p><p><strong>实现并集运算</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成集合 set 和集合 other 的并集</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Union</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> set == <span class="literal">nil</span> || other == <span class="literal">nil</span> &#123;    <span class="comment">// set和other都为nil，则它们的并集为nil</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">  unionedSet := NewHashSet()         <span class="comment">// 新创建一个HashSet类型值，它的长度为0，即元素数量为0</span></div><div class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> set.Elements() &#123; <span class="comment">// 将set中的元素添加到unionedSet中</span></div><div class="line">    unionedSet.Add(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> other.Len() == <span class="number">0</span> &#123;</div><div class="line">    <span class="keyword">return</span> unionedSet</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> other.Elements() &#123;  <span class="comment">// 将other中的元素添加到unionedSet中，如果遇到相同，则不添加（在Add方法逻辑中体现）</span></div><div class="line">    unionedSet.Add(v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> unionedSet</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>实现交集运算</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成集合 set 和集合 other 的交集</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Intersect</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> set == <span class="literal">nil</span> || other == <span class="literal">nil</span> &#123;   <span class="comment">// set和other都为nil，则它们的交集为nil</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">  intersectedSet := NewHashSet()    <span class="comment">// 新创建一个HashSet类型值，它的长度为0，即元素数量为0</span></div><div class="line">  <span class="keyword">if</span> other.Len() == <span class="number">0</span> &#123;             <span class="comment">// other的元素数量为0，直接返回intersectedSet</span></div><div class="line">    <span class="keyword">return</span> intersectedSet</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> set.Len() &lt; other.Len() &#123;      <span class="comment">// set的元素数量少于other的元素数量</span></div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> set.Elements() &#123;   <span class="comment">// 遍历set</span></div><div class="line">      <span class="keyword">if</span> other.Contains(v) &#123;        <span class="comment">// 只要将set和other共有的添加到intersectedSet</span></div><div class="line">        intersectedSet.Add(v)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;                          <span class="comment">// set的元素数量多于other的元素数量</span></div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> other.Elements() &#123;   <span class="comment">// 遍历other</span></div><div class="line">      <span class="keyword">if</span> set.Contains(v) &#123;          <span class="comment">// 只要将set和other共有的添加到intersectedSet</span></div><div class="line">        intersectedSet.Add(v)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> intersectedSet</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>差集</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成集合 set 对集合 other 的差集</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Difference</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> set == <span class="literal">nil</span> || other == <span class="literal">nil</span> &#123;  <span class="comment">// set和other都为nil，则它们的差集为nil</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">  differencedSet := NewHashSet()   <span class="comment">// 新创建一个HashSet类型值，它的长度为0，即元素数量为0</span></div><div class="line">  <span class="keyword">if</span> other.Len() == <span class="number">0</span> &#123;            <span class="comment">// 如果other的元素数量为0</span></div><div class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> set.Elements() &#123;  <span class="comment">// 遍历set，并将set中的元素v添加到differencedSet</span></div><div class="line">      differencedSet.Add(v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> differencedSet          <span class="comment">// 直接返回differencedSet</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> set.Elements() &#123;  <span class="comment">// other的元素数量不为0，遍历set</span></div><div class="line">    <span class="keyword">if</span> !other.Contains(v) &#123;        <span class="comment">// 如果other中不包含v，就将v添加到differencedSet中</span></div><div class="line">      differencedSet.Add(v)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> differencedSet</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>对称差集</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 生成集合 one 和集合 other 的对称差集</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">SymmetricDifference</span><span class="params">(other *HashSet)</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> set == <span class="literal">nil</span> || other == <span class="literal">nil</span> &#123;  <span class="comment">// set和other都为nil，则它们的对称差集为nil</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">  diffA := set.Difference(other)   <span class="comment">// 生成集合 set 对集合 other 的差集</span></div><div class="line">  <span class="keyword">if</span> other.Len() == <span class="number">0</span> &#123;            <span class="comment">// 如果other的元素数量等于0，那么other对集合set的差集为空，则直接返回diffA</span></div><div class="line">    <span class="keyword">return</span> diffA</div><div class="line">  &#125;</div><div class="line">  diffB := other.Difference(set)   <span class="comment">// 生成集合 other 对集合 set 的差集</span></div><div class="line">  <span class="keyword">return</span> diffA.Union(diffB)        <span class="comment">// 返回集合 diffA 和集合 diffB 的并集</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>4.进一步重构</strong></p><p>目前所实现的 <strong>HashSet </strong>类型提供了一些必要的集合操作功能，但是不同应用场景下可能会需要使用功能更加丰富的集合类型。当有多个集合类型的时候，应该在它们之上抽取出一个接口类型以标识它们共有的行为方式。依据 <strong>HashSet </strong>类型的声明，可以如下声明 Set 接口类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Set <span class="keyword">interface</span> &#123;</div><div class="line">  Add(e <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line">  Remove(e <span class="keyword">interface</span>&#123;&#125;)</div><div class="line">  Clear()</div><div class="line">  Contains(e <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></div><div class="line">  Len() <span class="keyword">int</span></div><div class="line">  Same(other Set) <span class="keyword">bool</span></div><div class="line">  Elements() []<span class="keyword">interface</span>&#123;&#125;</div><div class="line">  String() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注意：</strong> <strong>Set </strong>中的 <strong>Same </strong>方法的签名与附属于 <strong>HashSet</strong>类型的 <strong>Same </strong>方法有所不同。这里不能再接口类型的方法的签名中包含它的实现类型。因此这里的改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Same</span><span class="params">(other Set)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  <span class="comment">// 省略若干语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>修改了 <strong>Same </strong>方法的签名，目的是让 <strong>*HashSet </strong>类型成为 Set 接口类型的一个实现类型。</p><p>高级功能的方法应该适用于所有的实现类型，完全可以抽离出成为独立的函数。并且，也不应该在每个实现类型中重复地实现这些高级方法。如下为改造后的 <strong>IsSuperset </strong>方法的声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断集合 one 是否是集合 other 的超集</span></div><div class="line"><span class="comment">// 读者应重点关注IsSuperset与附属于HashSet类型的IsSuperset方法的区别</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSuperset</span><span class="params">(one Set, other Set)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> one == <span class="literal">nil</span> || other == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  oneLen := one.Len()</div><div class="line">  otherLen := other.Len()</div><div class="line">  <span class="keyword">if</span> oneLen == <span class="number">0</span> || oneLen == otherLen &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> oneLen &gt; <span class="number">0</span> &amp;&amp; otherLen == <span class="number">0</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> other.Elements() &#123;</div><div class="line">    <span class="keyword">if</span> !one.Contains(v) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上就是Go语言之自定义集合Set的全部内容，希望对大家学习Go语言有所帮助。</p><p>点此查看代码<a href="https://github.com/hyper0x/goc2p" target="_blank" rel="external">github代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在集合代数中除了对集合基本性质和规律的描述外，还包含了对各种集合运算和集合关系的说明。集合的运算包括并集，交集，差集还有对称差集。集合的关系包括相等和真包含。这篇文章我们就来实现这些功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>说说itoa的使用</title>
    <link href="https://yangchenglong11.github.io/2016/10/25/%E8%AF%B4%E8%AF%B4itoa%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://yangchenglong11.github.io/2016/10/25/说说itoa的使用/</id>
    <published>2016-10-25T08:24:15.000Z</published>
    <updated>2017-10-03T12:17:52.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><p>iota是golang语言的常量计数器,只能在常量的表达式中使用。</p><a id="more"></a><p>iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。</p><p>使用iota能简化定义，在定义枚举时很有用。</p><p><strong>举例如下：</strong></p><p>1、iota只能在常量的表达式中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(<span class="literal">iota</span>)</div></pre></td></tr></table></figure><p>编译错误： undefined: iota</p><p>2、每次 const 出现时，都会让 iota 初始化为0.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a=0 </span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( </div><div class="line">  b = <span class="literal">iota</span>     <span class="comment">//b=0 </span></div><div class="line">  c            <span class="comment">//c=1 </span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line"></div><div class="line"><span class="comment">// Set alarm consts</span></div><div class="line">ALARM_LEVEL = <span class="number">3</span></div><div class="line"></div><div class="line"><span class="comment">// Create constants using 'iota' and start from 1 (iota starts from zero)</span></div><div class="line">GET = <span class="literal">iota</span> + <span class="number">1</span>   <span class="comment">// 2</span></div><div class="line">SET              <span class="comment">// 3</span></div><div class="line">DEL              <span class="comment">// 4</span></div><div class="line">)</div></pre></td></tr></table></figure><p>3、自定义类型</p><p>自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Stereotype <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( </div><div class="line">    TypicalNoob Stereotype = <span class="literal">iota</span> <span class="comment">// 0 </span></div><div class="line">    TypicalHipster                <span class="comment">// 1 </span></div><div class="line">    TypicalUnixWizard             <span class="comment">// 2 </span></div><div class="line">    TypicalStartupFounder         <span class="comment">// 3 </span></div><div class="line">)</div></pre></td></tr></table></figure><p>4、可跳过的值</p><p>我们可以使用下划线跳过不想要的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> AudioOutput <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( </div><div class="line">    OutMute AudioOutput = <span class="literal">iota</span> <span class="comment">// 0 </span></div><div class="line">    OutMono                    <span class="comment">// 1 </span></div><div class="line">    OutStereo                  <span class="comment">// 2 </span></div><div class="line">    _ </div><div class="line">    _ </div><div class="line">    OutSurround                <span class="comment">// 5 </span></div><div class="line">)</div></pre></td></tr></table></figure><p>5、位掩码表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Allergen <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ( </div><div class="line">    IgEggs_Allergen = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 &lt;&lt; 0 which is 00000001 </span></div><div class="line">    IgChocolate                         <span class="comment">// 1 &lt;&lt; 1 which is 00000010 </span></div><div class="line">    IgNuts                              <span class="comment">// 1 &lt;&lt; 2 which is 00000100 </span></div><div class="line">    IgStrawberries                      <span class="comment">// 1 &lt;&lt; 3 which is 00001000 </span></div><div class="line">    IgShellfish                         <span class="comment">// 1 &lt;&lt; 4 which is 00010000 </span></div><div class="line">)</div></pre></td></tr></table></figure><p>这个工作是因为当你在一个 const 组中仅仅有一个标示符在一行的时候，它将使用增长的 iota 取得前面的表达式并且再运用它，。在 Go 语言的 spec 中， 这就是所谓的隐性重复最后一个非空的表达式列表。</p><p>如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值 00010011，它对应十进制的 19。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fmt.Println(IgEggs | IgChocolate | IgShellfish)</div><div class="line"><span class="comment">// output: </span></div><div class="line"><span class="comment">// 19</span></div></pre></td></tr></table></figure><p>6、定义数量级</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ByteSize <span class="keyword">float64</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    _           = <span class="literal">iota</span>                   <span class="comment">// ignore first value by assigning to blank identifier</span></div><div class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 1 &lt;&lt; (10*1)</span></div><div class="line">    MB                                   <span class="comment">// 1 &lt;&lt; (10*2)</span></div><div class="line">    GB                                   <span class="comment">// 1 &lt;&lt; (10*3)</span></div><div class="line">    TB                                   <span class="comment">// 1 &lt;&lt; (10*4)</span></div><div class="line">    PB                                   <span class="comment">// 1 &lt;&lt; (10*5)</span></div><div class="line">    EB                                   <span class="comment">// 1 &lt;&lt; (10*6)</span></div><div class="line">    ZB                                   <span class="comment">// 1 &lt;&lt; (10*7)</span></div><div class="line">    YB                                   <span class="comment">// 1 &lt;&lt; (10*8)</span></div><div class="line">)</div></pre></td></tr></table></figure><p>7、定义在一行的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    Apple, Banana = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span></div><div class="line">    Cherimoya, Durian</div><div class="line">    Elderberry, Fig</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//iota 在下一行增长，而不是立即取得它的引用。</span></div><div class="line"><span class="comment">// Apple: 1 </span></div><div class="line"><span class="comment">// Banana: 2 </span></div><div class="line"><span class="comment">// Cherimoya: 2 </span></div><div class="line"><span class="comment">// Durian: 3 </span></div><div class="line"><span class="comment">// Elderberry: 3 </span></div><div class="line"><span class="comment">// Fig: 4</span></div></pre></td></tr></table></figure><p> 8、中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ( </div><div class="line">    i = <span class="literal">iota</span> </div><div class="line">    j = <span class="number">3.14</span> </div><div class="line">    k = <span class="literal">iota</span> </div><div class="line">    l </div><div class="line">)</div></pre></td></tr></table></figure><p>那么打印出来的结果是 i=0,j=3.14,k=2,l=3</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iota&quot;&gt;&lt;a href=&quot;#iota&quot; class=&quot;headerlink&quot; title=&quot;iota&quot;&gt;&lt;/a&gt;iota&lt;/h1&gt;&lt;p&gt;iota是golang语言的常量计数器,只能在常量的表达式中使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 字符串格式化</title>
    <link href="https://yangchenglong11.github.io/2016/10/21/Go-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://yangchenglong11.github.io/2016/10/21/Go-字符串格式化/</id>
    <published>2016-10-21T07:12:53.000Z</published>
    <updated>2017-10-03T12:15:07.531Z</updated>
    
    <content type="html"><![CDATA[<p>写代码时经常会用到字符串，这里总结下 Go 语言中常用的字符串格式化例子。</p><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line"><span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</div><div class="line">x, y <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">// Go提供了几种打印格式，用来格式化一般的Go值</span></div><div class="line"><span class="comment">// 下面的%v打印了一个结构体的对象的值</span></div><div class="line">p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 如果所格式化的值是一个结构体对象，那么%+v的格式化输出将包括结构体的成员名称和值</span></div><div class="line">fmt.Printf(<span class="string">"%+v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// %#v格式化输出将输出一个值的Go语法表示方式。</span></div><div class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%T来输出一个值的数据类型</span></div><div class="line">fmt.Printf(<span class="string">"%T\n"</span>, p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%p输出一个指针的值</span></div><div class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;p)</div><div class="line"></div><div class="line"><span class="comment">// 使用%#p输出一个不带0x的指针的值</span></div><div class="line">fmt.Printf(<span class="string">"%#p\n"</span>, &amp;p)</div><div class="line"></div><div class="line"><span class="comment">// 格式化布尔型变量</span></div><div class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="comment">// 有很多的方式可以格式化整型，使用%d是一种标准的以10进制来输出整型的方式</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">123</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用%+d可以将符号也打印出来</span></div><div class="line">fmt.Printf(<span class="string">"%+d\n"</span>, <span class="number">123</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的二进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">14</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的不带零的八进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">16</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这种方式输出整型的带零的八进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%#o\n"</span>, <span class="number">16</span>)</div><div class="line"></div><div class="line"><span class="comment">// 这里打印出该整型数值所对应的字符，即A对应的ASCII值</span></div><div class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">33</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出一个值的小写的十六进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出一个值的一个值的大写的十六进制表示方式</span></div><div class="line">fmt.Printf(<span class="string">"%X\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出带0x的十六进制</span></div><div class="line">fmt.Printf(<span class="string">"%#x\n"</span>, <span class="number">456</span>)</div><div class="line"></div><div class="line"><span class="comment">// 浮点型数值也有几种格式化方法。最基本的一种是%f</span></div><div class="line">fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">78.9</span>)</div><div class="line"></div><div class="line"><span class="comment">// %e和%E使用科学计数法来输出整型</span></div><div class="line">fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">123400000.0</span>)</div><div class="line">fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">123400000.0</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用%s输出基本的字符串</span></div><div class="line">fmt.Printf(<span class="string">"%s\n"</span>, <span class="string">"\"string\""</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出像Go源码中那样带双引号的字符串，需使用%q</span></div><div class="line">fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"\"string\""</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出字符串带反引号，但字符串内部不能有`字符</span></div><div class="line">fmt.Printf(<span class="string">"%#q\n"</span>, <span class="string">"string"</span>)</div><div class="line"></div><div class="line"><span class="comment">// %x以16进制输出字符串，每个字符串的字节用两个字符输出，大小写同前</span></div><div class="line">fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"hex this"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 当输出数字的时候，经常需要去控制输出的宽度和精度。可以使用一个位于%后面的数字来控制输出的宽度</span></div><div class="line"><span class="comment">// 默认情况下输出是右对齐的，左边加上空格</span></div><div class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以指定浮点数的输出宽度，同时你还可以指定浮点数的输出精度</span></div><div class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</div><div class="line"></div><div class="line"><span class="comment">// 用最少的数字来表示浮点数</span></div><div class="line">fmt.Printf(<span class="string">"%g\n"</span>, <span class="number">1.23</span>)</div><div class="line"></div><div class="line"><span class="comment">// 用最多3位数字来表示浮点数</span></div><div class="line">fmt.Printf(<span class="string">"%.3g\n"</span>, <span class="number">12.34</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 - 符号，进行左对齐</span></div><div class="line">fmt.Printf(<span class="string">"|%-6.3f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 %05d 符号， 会在数字前面补零。</span></div><div class="line">fmt.Printf(<span class="string">"%05d\n"</span>, <span class="number">43</span>)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以指定输出字符串的宽度来保证它们输出对齐。默认情况下，输出是右对齐的</span></div><div class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 为了使用左对齐你可以在宽度之前加上-号</span></div><div class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</div><div class="line"></div><div class="line"><span class="comment">// Printf函数的输出是输出到命令行os.Stdout的，你可以用Sprintf来将格式化后的字符串赋值给一个变量</span></div><div class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</div><div class="line">fmt.Println(s)</div><div class="line"></div><div class="line"><span class="comment">// 你也可以使用Fprintf来将格式化后的值输出到io.Writers</span></div><div class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&#123;1 2&#125;</div><div class="line">&#123;x:1 y:2&#125;</div><div class="line">main.point&#123;x:1, y:2&#125;</div><div class="line">main.point</div><div class="line">0xc42007e010</div><div class="line">c42007e010</div><div class="line">true</div><div class="line">123</div><div class="line">+123</div><div class="line">1110</div><div class="line">20</div><div class="line">020</div><div class="line">!</div><div class="line">1c8</div><div class="line">1C8</div><div class="line">0x1c8</div><div class="line">78.900000</div><div class="line">1.234000e+08</div><div class="line">1.234000E+08</div><div class="line"><span class="string">"string"</span></div><div class="line"><span class="string">"\"string\""</span></div><div class="line">`string`</div><div class="line">6865782074686973</div><div class="line">|<span class="string">    12</span>|<span class="string">   345</span>|</div><div class="line">|<span class="string">  1.20</span>|<span class="string">  3.45</span>|</div><div class="line">1.23</div><div class="line">12.3</div><div class="line">|<span class="string">1.200 </span>|<span class="string">3.45  </span>|</div><div class="line">00043</div><div class="line">|<span class="string">   foo</span>|<span class="string">     b</span>|</div><div class="line">|<span class="string">foo   </span>|<span class="string">b     </span>|</div><div class="line">a string</div><div class="line">an error</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码时经常会用到字符串，这里总结下 Go 语言中常用的字符串格式化例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 实现set</title>
    <link href="https://yangchenglong11.github.io/2016/10/17/Go-%E5%AE%9E%E7%8E%B0set/"/>
    <id>https://yangchenglong11.github.io/2016/10/17/Go-实现set/</id>
    <published>2016-10-17T01:23:34.000Z</published>
    <updated>2017-10-03T12:15:15.678Z</updated>
    
    <content type="html"><![CDATA[<p>练习利用go语言的标准数据类型map实现python语言中的set数据结构。</p><a id="more"></a><p>其他语言中，set的底层都是由哈希表(Hash Table)来实现的，go语言拥有作为Hash Table实现的字典Map类型。我们在对Set和Map进行比较之后会发现他们在一些主要特性上是及其相似的如下：</p><ul><li>他们中的元素都是不可重复的。</li><li>他们都只能用迭代的方式取出其中的所有元素。</li><li>对他们中的元素进行迭代的顺序都是与元素插入顺序无关的，同时也不保证任何有序性，虽然有一些区别。</li><li>Set的元素是一个单一的值，而map的元素则是一个键值对。</li><li>Set的元素不可重复指的是不能存在任意两个单一值相等的情况。map的元素不可重复指的是任意两个键值对中的键的值不能相等。</li></ul><p>我们可以发现Set更像是Map的一种简化版本，我们可不可以利用Map来编写一个Set的实现呢？答案当然是肯定的。</p><p>基本定义</p><p>首先，我们创建一个名为hash_set.go的源码文件，把它放在项目的代码包set中。我们需要首先在这个源码文件的第一行上写入这样一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> set</div></pre></td></tr></table></figure><p>这是为了声明源码文件hash_set.go是代码包set中的一员。然后我们声明一个包含了一个字典类型的字段的结构体类型。声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> HashSet <span class="keyword">struct</span> &#123;</div><div class="line">m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类型声明中的唯一的字段是map[interface{}]bool。之所以选择这样的一个字典类型是有原因的。因为我们希望HashSet类型的元素可以是任意类型的，所以我们将字典m的键类型设置为了interface{}。又由于我们只需要用到m的值中的键来储存HashSet类型的元素值，所以就应该选用值占用空间最小的类型来作为m的值的元素类型，这里使用bool类型有3个好处：</p><ul><li>从值的储存形式的角度看，bool类型值的占用空间是最小的之一，只占用一个字节。</li><li>从值的表示形式的角度看，bool类型的值只有两个，这两个值都是预定义常量。</li><li>把bool类型作为值类型更有利于判断字典类型中是否存在某个键。例如，我们可以用m[“a”]的结果值体现m的值中是否包含键为”a”键值对，但是，如果m的类型是map[interface{}]byte的话，那么我们只有通过v, ok := m[“a”],才能确切得出上述判断的结果。虽然在向map[interface{}]byte类型的m的值添加键值对的时候，我们可以总以非零值的byte类型值作为其中的元素的值，但是我们在做判断的时候就需要编写更多的代码：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> v := m[<span class="string">"a"</span>]; v != <span class="number">0</span> &#123; <span class="comment">// 如果“m“中不存在以”"a"作为键的键值对</span></div><div class="line">    <span class="comment">// 省略若干语句</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对于map[interface&#123;&#125;]bool类型的值来说</span></div><div class="line"><span class="keyword">if</span> m[<span class="string">"a"</span>]&#123;  <span class="comment">// 如果“m“中不存在以”"a"作为键的键值对</span></div><div class="line">   <span class="comment">// 省略若干语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来我们考虑初始化HashSet类型值的问题。由于字典类型的零值为nil，所以我们不能简单使用new函数来创建一个HashSet类型值，因为 new(HashSet).m 的求值结果将会是一个 nil 。因此，这里需要编写一个专门用于创建和初始化 HashSet 类型值的函数，该函数声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHashSet</span><span class="params">()</span> *<span class="title">HashSet</span></span> &#123;</div><div class="line">      <span class="keyword">return</span> &amp;HashSet&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上可以看到，使用make函数对字段m进行了初始化。同时注意观察函数 NewHashSet 的结果声明的类型是 <em>HashSet 而不是 HashSet，目的是让这个结果值的方法集合中包含调用接收者类型为 HashSet 或 </em>HashSet 的所有方法。这样做的好处将在后面编写 Set 接口类型的时候再予以说明。</p><p>2.基本功能</p><p>依据其他编程语言中的 HashSet 类型可知，它们大部分应该提供的基本功能如下：</p><ul><li>添加元素值。</li><li>删除元素值。</li><li>清除所有元素值。</li><li>判断是否包含某个元素值。</li><li>获取元素值的数量。</li><li>判断与其他HashSet类型值是否相同。</li><li>获取所有元素值，即生成可迭代的快照。</li><li>获取自身的字符串表示形式。</li></ul><p>(1).添加元素值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法Add会返回一个bool类型的结果值，以表示添加元素值的操作是否成功。</span></div><div class="line"><span class="comment">// 方法Add的声明中的接收者类型是*HashSet。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Add</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line">   <span class="keyword">if</span> !set.m[e] &#123;         <span class="comment">// 当前的m的值中还未包含以e的值为键的键值对</span></div><div class="line">      set.m[e] = <span class="literal">true</span>     <span class="comment">// 将键为e(代表的值)、元素为true的键值对添加到m的值当中</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>         <span class="comment">// 添加成功</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">false</span>           <span class="comment">// 添加失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用 *HashSet 而不是 HashSet，主要是从节约内存空间的角度出发，分析如下：</p><p>当 Add 方法的接收者类型为 HashSet 的时候，对它的每一次调用都需要对当前 HashSet 类型值进行一次复制。虽然在 HashSet 类型中只有一个引用类型的字段，但是这也是一种开销。而且这里还没有考虑 HashSet 类型中的字段可能会变得更多的情况。</p><p>当 Add 方法的接收者类型为 <em>HashSet 的时候，对它进行调用时复制的当前 </em>HashSet 的类型值只是一个指针值。在大多数情况下，一个指针值占用的内存空间总会被它指向的那个其他类型的值所占用的内存空间小。无论一个指针值指向的那个其他类型值所需的内存空间有多么大，它所占用的内存空间总是不变的。</p><p>(2).删除元素值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用delete内建函数删除HashSet内部支持的字典值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Remove</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line"><span class="built_in">delete</span>(set.m, e)<span class="comment">//第一个参数为目标字典类型，第二个参数为要删除的那个键值对的键</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(3).清除所有元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为HashSet中的字段m重新赋值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</div><div class="line">set.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">bool</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果接收者类型是 HashSet，该方法中的赋值语句的作用只是为当前值的某个复制品中的字段m赋值而已，而当前值中的字段 m 则不会被重新赋值。方法 Clear 中的这条赋值语句被执行之后，当前的 HashSet 类型值中的元素就相当于被清空了。已经与字段 m 解除绑定的那个旧的字典值由于不再与任何程序实体存在绑定关系而成为了无用的数据。它会在之后的某一时刻被Go语言的垃圾回收器发现并回收。</p><p>(4).判断是否包含某个元素值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Contains用于判断其值是否包含某个元素值。</span></div><div class="line"><span class="comment">//这里判断结果得益于元素类型为bool的字段m</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Contains</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</div><div class="line"><span class="keyword">return</span> set.m[e]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当把一个 interface{} 类型值作为键添加到一个字典值的时候，Go语言会先获取这个 interface{} 类型值的实际类型（即动态类型），然后再使用与之对应的 hash 函数对该值进行 hash 运算，也就是说，interface{} 类型值总是能够被正确地计算出 hash 值。但是字典类型的键不能是函数类型、字典类型或切片类型，否则会引发一个运行时恐慌，并提示如下： </p><pre><code>panic: runtime error: hash of unhashable type &lt;某个函数类型、字典类型或切片类型的名称&gt;</code></pre><p>(5).获取元素值的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Len用于获取HashSet元素值数量</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(set.m)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(6).判断与其他HashSet类型值是否相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Same用来判断两个HashSet类型值是否相同</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Same</span><span class="params">(other *HashSet)</span> <span class="title">bool</span></span> &#123;</div><div class="line"><span class="keyword">if</span> other == <span class="literal">nil</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> set.Len() != other.Len() &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> !other.Contains(key) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>两个 HashSet 类型值相同的必要条件是，它们包含的元素应该是完全相同的。由于 HashSet 类型值中的元素的迭代顺序总是不确定的，所以也就不用在意两个值在这方面是否一致。如果要判断两个 HashSet 类型值是否是同一个值，就需要利用指针运算进行内存地址的比较。</p><p>(7).获取所有元素值，即生成可迭代的快照。</p><p>所谓 快照，就是目标值在某一个时刻的映像。对于一个 HashSet 类型值来说，它的快照中的元素迭代顺序总是可以确定的，快照只反映了该 HashSet 类型值在某一个时刻的状态。另外，还需要从元素可迭代且顺序可确定的数据类型中选取一个作为快照的类型。这个类型必须是以单值作为元素的，所以字典类型最先别排除。又由于 HashSet 类型值中的元素数量总是不固定的，所以无法用一个数组类型的值来表示它的快照。如上分析可知，Go语言中可以使用的快照的类型应该是一个切片类型或者通道类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法Elements用于生成快照</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">Elements</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">initialLen := <span class="built_in">len</span>(set.m)</div><div class="line"><span class="comment">//初始化一个[]interface&#123;&#125;类型的变量snapshot来存储m的值中的元素值</span></div><div class="line">snapshot := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, initialLen)</div><div class="line">actualLen := <span class="number">0</span></div><div class="line"><span class="comment">//按照既定顺序将迭代值设置到快照值(变量snapshot的值)的指定元素位置上,这一过程并不会创建任何新值。</span></div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> actualLen &lt; initialLen &#123;</div><div class="line">snapshot[actualLen] = key</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">snapshot = <span class="built_in">append</span>(snapshot, key)</div><div class="line">&#125;</div><div class="line">actualLen++ <span class="comment">//实际迭代的次数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> actualLen &lt; initialLen &#123;</div><div class="line">snapshot = snapshot[:actualLen]</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> snapshot</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之所以我们使用这么多条语句来实现这个方法是因为需要考虑到在从获取字段m的值的长度到对m的值迭代完成的这个时间段内，m的值中的元素数量可能发生变化。如果在迭代完成之前，m的值中的元素数量有所增加，使得实际迭代的次数大于先前初始化的快照值的长度 ，那么我们再使用appeng函数向快照值追加元素值。这样做既提高了快照生成的效率，又不至于在元素数量增加时引发索引越界的运行时恐慌。</p><p>对于已被初始化的[]interface{}类型的切片值来说，未被显示初始化的元素位置上的值均为nil。如果在迭代完成前，m的值中的元素数量有所减少， 致使快照值的尾部存在若干个没有任何意义的值为nil的元素，我们需要把这些无用的元素从快照中去掉。可以通过snapshot = snapshot[:actualLen]将无用的元素值从快照值中去掉。</p><p>注意：在 Elements 方法中针对并发访问和修改 m 的值的情况采取了一些措施。但是由于m的值本身并不是并发安全的，所以并不能保证 Elements 方法的执行总会准确无误。要做到真正的并发安全，还需要一些辅助的手段，比如读写互斥量。</p><p>(8).获取自身的字符串表示形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个String方法的签名算是一个惯用法。</span></div><div class="line"><span class="comment">//代码包fmt中的打印函数总会使用参数值附带的具有如此签名的String方法的结果值作为该参数值的字符串表示形式。</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *HashSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line"><span class="keyword">var</span> buf bytes.Buffer <span class="comment">//作为结果值的缓冲区</span></div><div class="line">buf.WriteString(<span class="string">"HashSet&#123;"</span>)</div><div class="line">first := <span class="literal">true</span></div><div class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> set.m &#123;</div><div class="line"><span class="keyword">if</span> first &#123;</div><div class="line">first = <span class="literal">false</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">buf.WriteString(<span class="string">","</span>)</div><div class="line">&#125;</div><div class="line">buf.WriteString(fmt.Sprintf(<span class="string">"%v"</span>, key))</div><div class="line">&#125;</div><div class="line"><span class="comment">//n := 1</span></div><div class="line"><span class="comment">//for key := range set.m &#123;</span></div><div class="line"><span class="comment">// buf.WriteString(fmt.Sprintf("%v", key))</span></div><div class="line"><span class="comment">// if n == len(set.m) &#123;//最后一个元素的后面不添加逗号</span></div><div class="line"><span class="comment">// break;</span></div><div class="line"><span class="comment">// &#125; else &#123;</span></div><div class="line"><span class="comment">// buf.WriteString(",")</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">// n++;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line">buf.WriteString(<span class="string">"&#125;"</span>)</div><div class="line"><span class="keyword">return</span> buf.Strin</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上已经完整地编写了一个具备常用功能的Set的实现类型，后面将讲解更多的高级功能来完善它。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;练习利用go语言的标准数据类型map实现python语言中的set数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="GO" scheme="https://yangchenglong11.github.io/categories/GO/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>假期小记</title>
    <link href="https://yangchenglong11.github.io/2016/10/08/%E5%81%87%E6%9C%9F%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yangchenglong11.github.io/2016/10/08/假期小记/</id>
    <published>2016-10-08T08:24:15.000Z</published>
    <updated>2017-10-03T12:15:39.508Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录了假期时看到的一些代码片段以及知识点，觉得不错就记录了下来。</p><a id="more"></a><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>Go 实现 map 排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"sort"</span></div><div class="line"><span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map_sort</span><span class="params">(ages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</div><div class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></div><div class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</div><div class="line">names = <span class="built_in">append</span>(names, name)</div><div class="line">&#125;</div><div class="line">sort.Strings(names)</div><div class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</div><div class="line">fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, ages[name])</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>要判断两个 map 是否包含相同的 key 和 value，我们必须通过一个循环实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> k, xv := <span class="keyword">range</span> x &#123;</div><div class="line"><span class="keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><p>Reader 接口的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>官方文档中关于该接口方法的说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;= n &lt;= len(p)） 以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。</span></div><div class="line"></div><div class="line"><span class="comment">//当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（同时 n == 0）。 一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，同时返回的err不是EOF就是nil。无论如何，下一个 Read 都应当返回 0, EOF。</span></div><div class="line"></div><div class="line"><span class="comment">//调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I/O错误。</span></div></pre></td></tr></table></figure><p>也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。</p><h3 id="Writer-接口"><a href="#Writer-接口" class="headerlink" title="Writer 接口"></a>Writer 接口</h3><p>Writer 接口的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</div><div class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>官方文档中关于该接口方法的说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个非nil的错误。</span></div></pre></td></tr></table></figure><p>同样的，所有实现了 Write 方法的类型都实现了 io.Writer 接口。</p><p>实现了 io.Reade r接口或 io.Writer 接口的类型 </p><p>我们可以知道，os.File 同时实现了这两个接口。我们还看到 os.Stdin/Stdout 这样的代码，它们似乎分别实现了 io.Reader/io.Writer 接口。没错，实际上在 os 包中有这样的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">Stdin  = NewFile(<span class="keyword">uintptr</span>(syscall.Stdin), <span class="string">"/dev/stdin"</span>)</div><div class="line">Stdout = NewFile(<span class="keyword">uintptr</span>(syscall.Stdout), <span class="string">"/dev/stdout"</span>)</div><div class="line">Stderr = NewFile(<span class="keyword">uintptr</span>(syscall.Stderr), <span class="string">"/dev/stderr"</span>)</div><div class="line">)</div></pre></td></tr></table></figure><p>也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件（即都是 os.File 的实例），自然也实现了 io.Reader 和io.Writer。</p><p>目前，Go 文档中还没法直接列出实现了某个接口的所有类型。不过，我们可以通过查看标准库文档，列出实现了io.Reader 或 io.Writer 接口的类型（导出的类型）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- os.File 同时实现了io.Reader和io.Writer</div><div class="line">- strings.Reader 实现了io.Reader</div><div class="line">- bufio.Reader/Writer 分别实现了io.Reader和io.Writer</div><div class="line">- bytes.Buffer 同时实现了io.Reader和io.Writer</div><div class="line">- bytes.Reader 实现了io.Reader</div><div class="line">- compress/gzip.Reader/Writer 分别实现了io.Reader和io.Writer</div><div class="line">- crypto/cipher.StreamReader/StreamWriter 分别实现了io.Reader和io.Writer</div><div class="line">- crypto/tls.Conn 同时实现了io.Reader和io.Writer</div><div class="line">- encoding/csv.Reader/Writer 分别实现了io.Reader和io.Writer</div><div class="line">- mime/multipart.Part 实现了io.Reader</div></pre></td></tr></table></figure><p>除此之外，io 包本身也有这两个接口的实现类型。如：</p><p>实现了Reader 的类型：LimitedReader、PipeReader、SectionReader</p><p>实现了 Writer 的类型：PipeWriter</p><p>以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片可以看作是对数组的一种包装形式，它所包装的数组称为该切片的底层数组。换句话说，切片是针对其底层数组中某个连续片段的描述符。</p><p>一个切片值总会持有一个对某个数组值的引用，事实上，一个切片值一旦被初始化，就会与一个包含了其中元素值的数组值相关联，即底层数组。多个切片值可能会共同用同一个底层数组。例如，如果把一个切片值复制成多个，或者针对其中的某个连续片段再切片成新的切片值，那么这些切片值所引用的都会是同一个底层数组。对切片值中的元素值的修改，实质上就是对底层数组上的对应元素的修改。从这个角度看，切片类似于指向底层数组的指针。反过来讲，对作为底层数组中元素值的改变，也会体现到引用该底层数组且包含该元素值的所有切片值上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录了假期时看到的一些代码片段以及知识点，觉得不错就记录了下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Web 后端和 Golang</title>
    <link href="https://yangchenglong11.github.io/2016/10/03/Web-%E5%90%8E%E7%AB%AF%E5%92%8CGO/"/>
    <id>https://yangchenglong11.github.io/2016/10/03/Web-后端和GO/</id>
    <published>2016-10-03T14:10:10.000Z</published>
    <updated>2017-10-03T12:14:53.309Z</updated>
    
    <content type="html"><![CDATA[<p>用最简单的话解释后端就是数据的处理，而前端是数据的呈现。<br><a id="more"></a> </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=473740555&auto=1&height=66"></iframe><p>根据正在处理的应用程序的大小和范围，后端开发人员要做的事情有很大的不同。以我的工作范围来说，实现业务逻辑，数据的创建和检索以及处理前端请求等。</p><p>在Web开发世界中，大多数后端开发人员从事于构建他们正在工作的应用程序背后的实际逻辑。</p><p>通常，前端开发人员构建用户界面，而后端开发人员编写代码，使其工作。</p><p>例如，前端开发人员在应用程序中创建一个界面，上面有一个按钮，按下按钮来获取客户的数据。</p><p>后端开发人员写可使得按钮工作的代码，通过指出从数据库中提取哪些数据并将其传回到前端（并最终显示在那里）。</p><p>后端开发人员也可能会大量参与系统架构，决定如何组织系统的逻辑，以便能够正常维护和运行。</p><p>他可能会参与构建框架或系统架构，以便于更容易编写程序。后端开发人员比前端开发人员花费更多的时间在实现算法和解决问题上。</p><p>这并不是说前端开发人员不解决难题，但是通常来说更难的功能实现，实际的业务逻辑都会再后端做。</p><h3 id="学后端需要学什么"><a href="#学后端需要学什么" class="headerlink" title="学后端需要学什么"></a>学后端需要学什么</h3><ul><li>后端开发语言<br>如：Golang，python，java，php，c#…..能够使用一门或多门开发语言来构造应用</li><li>数据库<br>掌握基本的增删改查，知道常见的数据库的优化以及运维，能够分析各种数据库的优缺点，知道什么时候用哪个数据库合适。</li><li>Linux使用</li><li>网络编程<br>熟悉掌握 http tcp/ip 协议</li><li>算法与数据结构</li><li>大数据</li><li>机器学习<br>……..<br>所以,路还是很长的….</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>我觉得学习一门语言最重要的就是做到三点,第一看基础知识,第二学习看代码,第三学习写代码.</p><p>  首先是基础语法<br>  有句话叫“基础不牢，地动山摇”。所以基础知识对以后的学习是很重要的，不只是语言方面，像上面说的数据库，网络之类的也是如此。重要，但不代表说我没有彻底掌握之前就停滞不前，就和它死磕到底，这并不是明智的做法。</p><p>  同时，也要注意，不要只看语法，也要有练习。golang官网就比较好，它有语法的文字描述，同时在旁边就有根据该语法给出的实例程序，加深理解。<br>  大家都已经学或正在学c++，其他语言就基础层面来说，简单的使用来说不会有太大差别。所以要学习其他语言，不必想c++这样花上将近一年的时间去学，把语法看下，大概有个印象就差不多了。不必要求全部记得，实际码代码时又不是考试，忘了可以回去查阅相关资料。</p><p>  接下来就是练习<br>  语法看完了，就像你们现在，c++学的差不多了，却不知道拿它能做什么。觉得语法好像是懂了，但怎么运用呢？<br>  我们要学会站在巨人的肩膀上，网上开源代码那么多，自己不会写，可以找一些大神写的自己感兴趣的源码clone到本地，仔细阅读分析他对语法是怎么运用的。</p><p>  当然，你down到本地的代码大多数不会只是讲解语法，因为这些开源出去的代码都是完成了某一功能的。简单的一些可能是利用这个语言实现了该语言所没有的数据结构，有的可能是一个网站的源码。<br>  这个阶段也是你提升最快的阶段，通过阅读源码，你可以学习到许多其他方面的知识，积累了经验。</p><p>  然后就是写了<br>  读书破万卷，下笔如有神。看了这么多源码，你也手痒了吧！来做一个项目练练手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用最简单的话解释后端就是数据的处理，而前端是数据的呈现。&lt;br&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 程序的基本结构和要素</title>
    <link href="https://yangchenglong11.github.io/2016/10/02/Go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%A6%81%E7%B4%A0/"/>
    <id>https://yangchenglong11.github.io/2016/10/02/Go-程序的基本结构和要素/</id>
    <published>2016-10-02T02:23:14.000Z</published>
    <updated>2017-10-03T12:15:26.885Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要介绍 Go 语言的基本信息。</p><a id="more"></a><h3 id="Go-环境变量"><a href="#Go-环境变量" class="headerlink" title="Go 环境变量"></a>Go 环境变量</h3><p>Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之间就已经设置好他们。</p><p>如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：</p><ul><li><code>$GOROOT</code> 表示 Go 在你的电脑上的安装位置，它的值一般都是 <code>$HOME/go</code>，当然，你也可以安装在别的地方。</li><li><code>$GOARCH</code> 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。</li><li><code>$GOOS</code> 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。</li><li><code>$GOBIN</code> 表示编译器和链接器的安装位置，默认是 <code>$GOROOT/bin</code>，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。</li></ul><p>目标机器是指你打算运行你的 Go 应用程序的机器。</p><p>Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。</p><p>为了区分本地机器和目标机器，你可以使用 <code>$GOHOSTOS</code> 和 <code>$GOHOSTARCH</code> 设置目标机器的参数，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（<code>$GOOS</code> 和 <code>$GOARCH</code>）一样。</p><ul><li><code>$GOPATH</code> 默认采用和 <code>$GOROOT</code> 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</li><li><code>$GOARM</code> 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。</li><li><code>$GOMAXPROCS</code> 用于设置应用程序可使用的处理器个数与核数</li></ul><h3 id="包的概念、导入与可见性"><a href="#包的概念、导入与可见性" class="headerlink" title="包的概念、导入与可见性"></a>包的概念、导入与可见性</h3><p>包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line">    </div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   fmt.Println(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p><p>你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p><p>一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 <code>package main</code> 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 <code>pkg\windows_386</code> 中；在 Linux 下，标准库在 Go 根目录下的子目录 <code>pkg\linux_amd64</code> 中（如果是安装的是 32 位，则在 linux<em>386 目录中）。一般情况下，标准包会存放在 `$GOROOT/pkg/$GOOS</em>$GOARCH/` 目录下。</p><p>Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。</p><p>如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。</p><p>属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。</p><p>如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。</p><p>Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。</p><p>如果 A.go 依赖 B.go，而 B.go 又依赖 C.go：</p><ul><li>编译 C.go, B.go, 然后是 A.go.</li><li>为了编译 A.go, 编译器读取的是 B.o 而不是 C.o.</li></ul><p>这种机制对于编译大型的项目时可以显著地提升编译速度。</p><p><strong>每一段代码只会被编译一次</strong></p><p>一个 Go 程序是通过 import 关键字将一组包链接在一起。</p><p><code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 “” 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。</p><p>如果需要多个包，它们可以被分别导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"os"</span></div></pre></td></tr></table></figure><p>或：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>; <span class="keyword">import</span> <span class="string">"os"</span></div></pre></td></tr></table></figure><p>但是还有更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"><span class="string">``</span><span class="string">`   </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">它甚至还可以更短的形式，但使用 gofmt 后将会被强制换行：</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></div><div class="line"><span class="keyword">import</span> (<span class="string">"fmt"</span>; <span class="string">"os"</span>)</div></pre></td></tr></table></figure><p>当你导入多个包时，导入的顺序会按照字母排序。</p><p>如果包名不是以 . 或 / 开头，如 “fmt” 或者 “container/list”，则 Go 会在全局文件进行查找；如果包名以 ./ 开头，则 Go 会在相对目录中查找；如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。</p><p>导入包即等同于包含了这个包的所有的代码对象。</p><p>除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。</p><p>包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：</p><h3 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h3><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</p><p>（大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。</p><p>因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。</p><p>假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。</p><p>因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 <code>pack1.Thing</code> 和 <code>pack2.Thing</code>。</p><p>你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：<code>import fm &quot;fmt&quot;</code>。下面的代码展示了如何使用包的别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line">    </div><div class="line"><span class="keyword">import</span> fm <span class="string">"fmt"</span> <span class="comment">// alias3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fm.Println(<span class="string">"hello, world"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意事项 </p><p>如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 <code>imported and not used: os</code>，这正是遵循了 Go 的格言：“没有不必要的代码！“。</p><p>包的分级声明和初始化</p><p>你可以在使用 import 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用（如 gotemplate.go 源文件中的 c 和 v），然后声明一个或多个函数（func）。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>这是定义一个函数最简单的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">()</span></span></div></pre></td></tr></table></figure><p>你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。</p><p>main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 <code>undefined: main.main</code>。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误： </p><pre><code>func main must have no arguments and no return values results.</code></pre><p>在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 <code>main.main()</code>（如：C 语言），该函数一旦返回就表示程序已成功执行并立即退出。</p><p>函数里的代码（函数体）使用大括号 {} 括起来。</p><p>左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示：</p><pre><code>`build-error: syntax error: unexpected semicolon or newline before {`</code></pre><p>（这是因为编译器会产生 func main() ; 这样的结果，很明显这错误的）</p><p>Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误 。</p><p>右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行：</p><pre><code>func Sum(a, b int) int { return a + b }</code></pre><p>对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。</p><p>因此符合规范的函数一般写成如下的形式：</p><pre><code>func functionName(parameter_list) (return_value_list) {   …}</code></pre><p>其中：</p><ul><li><code>parameter_list</code> 的形式为 <code>(param1 type1, param2 type2, …)</code></li><li><code>return_value_list</code> 的形式为 <code>(ret1 type1, ret2 type2, …)</code></li></ul><p>只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。</p><p>下面这一行调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \n：</p><pre><code>fmt.Println（&quot;hello, world&quot;）</code></pre><p>使用 <code>fmt.Print(&quot;hello, world\n&quot;)</code> 可以得到相同的结果。</p><p>Print 和 Println 这两个函数也支持使用变量，如：<code>fmt.Println(arr)</code>。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</p><p>单纯地打印一个字符串或变量甚至可以使用预定义的方法来实现，如：<code>print、println 、 print(&quot;ABC&quot;)、println(&quot;ABC&quot;)、println(i)（带一个变量 i）</code>。</p><p>这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 fmt 中的相关函数。</p><p>当被调用函数的代码执行到结束符 } 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。</p><p>程序正常退出的代码为 0 即 <code>Program exited with code 0</code>；如果程序因为异常而被终止，则会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> <span class="comment">// Package implementing formatted I/O.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">fmt.Printf(<span class="string">"Καλημέρα κόσμε; or こんにちは 世界\n"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这个例子通过打印 <code>Καλημέρα κόσμε; or こんにちは 世界</code> 展示了如何在 Go 中使用国际化字符，以及如何使用注释。</p><p>注释不会被编译，但可以通过 godoc 来使用（第 3.6 节）。</p><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</p><p>每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可。当开发人员需要了解包的一些情况时，自然会用 godoc 来显示包的文档说明，在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起。另外，在多段注释之间应以空行分隔加以区分。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Package superman implements methods for saving the world.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Experience has shown that a small number of procedures can prove</span></div><div class="line"><span class="comment">// helpful when attempting to save the world.</span></div><div class="line"><span class="keyword">package</span> superman</div></pre></td></tr></table></figure><p>几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 “Abcd…” 作为开头。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// enterOrbit causes Superman to fly into low Earth orbit, a position</span></div><div class="line"><span class="comment">// that presents several possibilities for planet salvation.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterOrbit</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>godoc 工具（第 3.6 节）会收集这些注释并产生一个技术文档。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>可以包含数据的变量（或常量），可以使用不同的数据类型或类型来保存数据。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。</p><p>类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。</p><p>结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。</p><p>函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：</p><pre><code>func FunctionName (a typea, b typeb) typeFunc</code></pre><p>你可以在函数体中的某处返回使用类型为 typeFunc 的变量 var：</p><pre><code>return var</code></pre><p>一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如：</p><pre><code>func FunctionName (a typea, b typeb) (t1 type1, t2 type2)</code></pre><p>示例： 函数 Atoi (第 4.7 节)：func Atoi(s string) (i int, err error)</p><p>返回的形式：</p><pre><code>return var1, var2</code></pre><p>这种多返回值一般用于判断某个函数是否执行成功（true/false）或与其它返回值一同返回错误消息（详见之后的并行赋值）。</p><p>使用 type 关键字可以定义你自己的类型，你可能想要定义一个结构体(第 10 章)，但是也可以定义一个已经存在的类型的别名，如：</p><pre><code>type IZ int</code></pre><p>这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。</p><p>然后我们可以使用下面的方式声明变量：</p><pre><code>var a IZ = 5</code></pre><p>这里我们可以看到 int 是变量 a 的底层类型，这也使得它们之间存在相互转换的可能（第 4.2.6 节）。</p><p>如果你有多个类型需要定义，可以使用因式分解关键字的方式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> (</div><div class="line">IZ <span class="keyword">int</span></div><div class="line">FZ <span class="keyword">float64</span></div><div class="line">STR <span class="keyword">string</span></div><div class="line">)</div></pre></td></tr></table></figure><p>每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言。</p><h3 id="Go-程序的一般结构"><a href="#Go-程序的一般结构" class="headerlink" title="Go 程序的一般结构"></a>Go 程序的一般结构</h3><p>下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。</p><p>所有的结构将在这一章或接下来的章节中进一步地解释说明，但总体思路如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line"><span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> c = <span class="string">"C"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> v <span class="keyword">int</span> = <span class="number">5</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">// initialization of package</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span></div><div class="line">Func1()</div><div class="line"><span class="comment">// ...</span></div><div class="line">fmt.Println(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Method1</span><span class="params">()</span></span> &#123;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Func1</span><span class="params">()</span></span> &#123; <span class="comment">// exported function Func1</span></div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Go 程序的执行（程序启动）顺序如下：</p><ol><li>按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：</li><li>如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。</li><li>然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。</li><li>在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><pre><code>valueOfTypeB = typeB(valueOfTypeA)</code></pre><p>类型 B 的值 = 类型 B(类型 A 的值)</p><p>示例： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a := <span class="number">5.0</span></div><div class="line">b := <span class="keyword">int</span>(a)</div></pre></td></tr></table></figure><p>但这只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）。当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。</p><p>具有相同底层类型的变量之间可以相互转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a IZ = <span class="number">5</span></div><div class="line">c := <span class="keyword">int</span>(a)</div><div class="line">d := IZ(c)</div></pre></td></tr></table></figure><h3 id="Go-命名规范"><a href="#Go-命名规范" class="headerlink" title="Go 命名规范"></a>Go 命名规范</h3><p>干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 Get… 之类的字符，如果是用于修改某个对象，则使用 SetName。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍 Go 语言的基本信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="https://yangchenglong11.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
