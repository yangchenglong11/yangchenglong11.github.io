<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>PoA | yangcl&#39;s</title>
  <meta name="author" content="Yang Chenglong" />

  
  <meta name="description" content="Yangcl&#39;s Blog" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="PoA" />
  <meta property="og:site_name" content="yangcl&#39;s" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="yangcl&#39;s" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">yangcl&#39;s</a></h1>
  <h2><a href="/">悟已往之不谏，知来者之可追。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
      <li><a href="https://github.com/yangchenglong11">github</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-04-10T09:24:07.000Z"><a href="/2018/04/10/PoA/">2018-04-10</a></time>
      
      
  
    <h1 class="title">PoA</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="1-PoA-理论介绍"><a href="#1-PoA-理论介绍" class="headerlink" title="1. PoA 理论介绍"></a>1. PoA 理论介绍</h2><h3 id="1-1-以太坊中-PoA-产生的背景"><a href="#1-1-以太坊中-PoA-产生的背景" class="headerlink" title="1.1 以太坊中 PoA 产生的背景"></a>1.1 以太坊中 PoA 产生的背景</h3><p>如果你想用以太坊搭建一个联盟/私有链, 并要求该链交易成本更低甚至没有, 交易延时更低,并发更高, 还拥有完全的控制权(意味着被攻击概率更低). 目前以太坊采用 PoW 或后续的 casper 能否满足要求?<br><a id="more"></a></p>
<ul>
<li>首先, PoW 存在 <strong>51% 攻击问题</strong>, 恶意挖矿者超过全网算力的 51% 后基本上就能完全控制整个网络. 由于链无法被更改, 已上链的数据也无法更改, 但恶意挖矿者也可以做一些 DoS 攻击阻止合法交易上链,考虑到具有相同创世块的旷工都能加入你的网络, 潜在的安全隐患会长期存在.</li>
<li>其次, PoW <strong>大量的电力资源消耗</strong>也是需要作为后续成本考虑. PoS 可以解决部分 PoW 问题, 比如节约电力,在一定程度上保护了51％的攻击(恶意旷工会被惩罚), 但从控制权和安全考虑还有欠缺, 因为 PoS 还是允许任何符合条件的旷工加入。</li>
</ul>
<p>在已经运行的测试网络 Ropsten 中, 由于 PoW 设定的难度较低,恶意旷工滥用较低的 PoW 难度并将 gaslimit 扩大到90亿（正常是470万），发送大量的交易瘫痪了整个网络。而在此之前，攻击者也尝试了多次非常长的重组(reorgs)，导致不同客户端之间的分叉，甚至不同的版本。</p>
<p>这些攻击的根本原因是 PoW 网络的安全性依赖于背后的算力。而从零开始重新启动一个新的 testnet 将不会解决任何问题，因为攻击者可以一次又一次地进行相同的攻击。 Parity 团队决定采取紧急解决方案，回滚大量的块，并设置不允许 gaslimit 超过某一阈值的软分叉规则。</p>
<p>虽然 Parity 的解决方案可能在短期内有效, 但是这不是优雅的：Ethereum 本身应该具有动态 gaslimit 限制; 也不可移植：其他客户端需要自己实现新的软分叉逻辑; 并与同步模式不兼容, 也不支持轻客户端; 尽管并不完美，但是Parity 的解决方案仍然可行。 一个更长期的替代解决方案是使用 PoA 共识,相对简单并容易实现.</p>
<h3 id="1-2-PoA-的特点"><a href="#1-2-PoA-的特点" class="headerlink" title="1.2. PoA 的特点"></a>1.2. PoA 的特点</h3><ul>
<li>PoA 是依靠预设好的授权节点(signers)，负责产生 block.</li>
<li>可以由已授权的 signer 选举(投票超过50%)加入新的 signer。</li>
<li>即使存在恶意 signer,他最多只能攻击连续块(数量是 <code>(SIGNER_COUNT / 2) + 1)</code> 中的1个,期间可以由其他signer 投票踢出该恶意 signer。</li>
<li>可指定产生 block 的时间。</li>
</ul>
<h3 id="1-3-PoA需要解决的问题"><a href="#1-3-PoA需要解决的问题" class="headerlink" title="1.3. PoA需要解决的问题"></a>1.3. PoA需要解决的问题</h3><ol>
<li>如何控制挖矿频率,即出块时间</li>
<li>如何验证某个块的有效性</li>
<li>如何动态调整授权签名者(signers)列表,并全网动态同步</li>
<li>如何在 signers 之间分配挖矿的负载或者叫做挖矿的机会</li>
</ol>
<p>对应的解决办法如下:</p>
<ol>
<li>协议规定采用固定的 block 出块时间, 区块头中的时间戳间隔为 15s</li>
<li>先看看 block 同步的方法,从中来分析 PoA 中验证 block 的解决办法</li>
</ol>
<p>有两种同步 blockchain 的方法</p>
<ol>
<li>经典方法是从创世块开始挨个执行所有交易。 这是经过验证的，但是在 Ethereum 的复杂网络中，计算量非常大。</li>
<li>另一个是仅下载区块头并验证其有效性，之后可以从网络下载任意的近期状态对最近的区块头进行检查。</li>
</ol>
<p>显然第二种方法更好. 由于 PoA 方案的块可以仅由可信任的签名者来创建, 因此，客户端看到的每个块（或块头）可以与可信任签名者列表进行匹配。 要验证该块的有效性就必须得到该块对应的签名者列表, 如果签名者在该列表中带包该块有效. 这里的挑战是如何维护并及时更改的授权签名者列表？ 存储在智能合约中?不可行, 因为在快速轻量级同步期间无法访问状态。</p>
<p>因此, <strong>授权签名者列表必须完全包含在块头中</strong> 。那么需要改变块头的结构, 引入新的字段来满足投票机制吗? 这也不可行：改变这样的核心数据结构将是开发者的噩梦。</p>
<p>所以授权签名者名单必须完全符合当前的数据模型, 不能改变区块头中的字段，而是 <strong>复用当前可用的字段: Extra 字段. </strong></p>
<p><strong>Extra</strong> 是可变长数组, 对它的修改是 <code>非侵入</code> 操作, 比如 RLP,hash 操作都支持可变长数据. Extra 中包含所有签名者列表和当前节点的签名者对该区块头的签名数据(可以恢复出来签名者的地址).</p>
<ol>
<li>更新一个动态的签名者列表的方法是复用区块头中的 <strong>Coinbase 和 Nonce 字段</strong> ，以创建投票方案：</li>
</ol>
<ul>
<li>常规的块中这两个字段置为0</li>
<li>如果签名者希望对授权签名者列表进行更改，则将：<ul>
<li><strong>Coinbase</strong> 设置为被投票的签名者</li>
<li>将 <strong>Nonce</strong> 设置为 <strong>0</strong> 或 <strong>0xff … f</strong> 投票,代表 <strong>添加或移除</strong></li>
<li>任何同步的客户端都可以在块处理过程中“统计”投票，并通过投票结果来维护授权签名者列表。</li>
</ul>
</li>
</ul>
<p>为了避免一个无限的时间来统计投票，我们设置一个投票窗口, 为一个 epoch,长度是30000个block。每个 epoch的起始清空所有历史的投票, 并作为签名者列表的检查点. 这允许客户端仅基于检查点哈希进行同步，而不必重播在链路上完成的所有投票。</p>
<ol>
<li>目前的方案是在所有 signer 之间轮询出块, 并通过算法保证同一个 signer 只能签名 <code>(SIGNER_COUNT / 2) + 1)</code> 个 block 中第一个.</li>
</ol>
<p>综上, PoA 的工作流程如下:</p>
<ol>
<li>在创世块中指定一组初始授权的 signers, <strong>所有地址</strong> 保存在创世块 Extra 字段中</li>
<li>启动挖矿后, 该组 signers 开始对生成的 block 进行 <strong>签名并广播</strong></li>
<li><strong>签名结果</strong> 保存在区块头的 Extra 字段中</li>
<li>Extra 中更新当前高度已授权的 <strong>所有 signers 的地址</strong> ,因为有新加入或踢出的 signer</li>
<li>每一高度都有一个 signer 处于 IN-TURN 状态, 其他 signer 处于 OUT-OF-TURN 状态,  IN-TURN 的 signer 签名的 block 会<strong>立即广播</strong> , OUT-OF-TURN 的 signer 签名的 block 会 <strong>延时</strong>一点随机时间后再广播, 保证 IN-TURN的签名 block 有更高的优先级上链</li>
<li>如果需要加入一个新的 signer, signer 通过 API 接口发起一个 proposal, 该 proposal 通过复用区块头  <strong>Coinbase (新 signer 地址)和 Nonce(“0xffffffffffffffff”)</strong> 字段广播给其他节点. 所有已授权的 signers 对该新的 signer 进行”加入”投票, 如果赞成票超过 signers 总数的50%, 表示同意加入</li>
<li>如果需要踢出一个旧的 signer, 所有已授权的 signers 对该旧的 signer 进行”踢出”投票, 如果赞成票超过signers 总数的50%, 表示同意踢出</li>
</ol>
<h4 id="1-4-signer-对区块头进行签名"><a href="#1-4-signer-对区块头进行签名" class="headerlink" title="1.4 signer 对区块头进行签名"></a>1.4 signer 对区块头进行签名</h4><ol>
<li>Extra 的长度至少65字节以上(签名结果是65字节,即 R, S, V, V是0或1)</li>
<li>对 blockHeader中所有字段除了 Extra 的 <strong>后65字节</strong> 外进行 <strong>RLP 编码</strong></li>
<li>对编码后的数据进行 <code>Keccak256</code> <strong>hash</strong></li>
<li>签名后的数据(65字节)保存到 Extra 的 <strong>后65字节</strong> 中</li>
</ol>
<h4 id="1-5-授权策略"><a href="#1-5-授权策略" class="headerlink" title="1.5 授权策略"></a>1.5 授权策略</h4><p>以下建议的策略将减少网络流量和分叉</p>
<ul>
<li>如果签名者被允许签署一个块（在授权列表中，但最近没有签名）。<ul>
<li>计算下一个块的最优签名时间（父块时间+ BLOCK_PERIOD）。</li>
<li>如果签名人是 in-turn，立即进行签名和广播block。</li>
<li>如果签名者是 out-of-turn，延迟 <code>rand(SIGNER_COUNT * 500ms)</code> 后再签名并广播</li>
</ul>
</li>
</ul>
<h4 id="1-6-级联投票"><a href="#1-6-级联投票" class="headerlink" title="1.6 级联投票"></a>1.6 级联投票</h4><p>当移除一个授权的签名者时,可能会导致其他移除前的投票成立. 例: ABCD 4 个 signer, AB加入E,此时不成立(没有超过50%), 如果 ABC 移除 D, 会自动导致加入 E 的投票成立(2/3的投票比例)</p>
<h4 id="1-7-投票策略"><a href="#1-7-投票策略" class="headerlink" title="1.7 投票策略"></a>1.7 投票策略</h4><p>因为 blockchain 可能会小范围重组(small reorgs), 常规的投票机制(cast-and-forget, 投票和忘记)可能不是最佳的，因为包含单个投票的 block 可能不会在最终的链上,会因为已有最新的 block 而被抛弃。</p>
<p>一个简单但有效的办法是对 signers 配置”提议( proposal )”.例如 “add 0x…”, “drop 0x…”, 有多个并发的提议时, 签名代码”随机”选择一个提议注入到该签名者签名的 block 中,这样多个并发的提议和重组( reorgs )都可以保存在链上.</p>
<p>该列表可能在一定数量的 block/epoch 之后过期，提案通过并不意味着它不会被重新调用，因此在提议通过时不应立即丢弃。</p>
<ul>
<li>加入和踢除新的 signer 的投票都是立即生效的,参与下一次投票计数</li>
<li>加入和踢除都需要 <strong>超过当前 signer 总数的50%</strong> 的 signer 进行投票</li>
<li>可以踢除自己(也需要超过50%投票)</li>
<li>可以并行投票(A,B交叉对C,D进行投票), 只要最终投票数操作50%</li>
<li>进入一个新的 epoch, 所有之前的 pending 投票都作废, 重新开始统计投票</li>
</ul>
<h4 id="1-8-投票场景举例"><a href="#1-8-投票场景举例" class="headerlink" title="1.8 投票场景举例"></a>1.8 投票场景举例</h4><ul>
<li>ABC, C踢除B, A踢除C, B踢除C, A踢除B, 结果是剩下 AB</li>
<li>ABCD, AB先分别踢除CD, C踢除D, 即使C投给自己留下的票, 结果是剩下 AB</li>
<li>ABCDE, ABC先分别加入F(成功,ABCDEF), BCDE踢除F(成功,ABCDE), DE 加入F(失败,ABCDE), BCD踢除A(成功, BCDE), B加入F(此时BDE加入F,满足超过50%投票), 结果是剩下 BCDEF</li>
</ul>
<h3 id="1-9-PoA中的攻击及防御"><a href="#1-9-PoA中的攻击及防御" class="headerlink" title="1.9 PoA中的攻击及防御"></a>1.9 PoA中的攻击及防御</h3><ul>
<li>恶意签名者(Malicious signer). 恶意用户被添加到签名者列表中，或签名者密钥/机器遭到入侵. 解决方案是，N个授权签名人的列表，任一签名者只能对每K个 block 签名其中的1个。这样尽量减少损害，其余的矿工可以投票踢出恶意用户。</li>
<li>审查签名者(Censoring signer). 如果一个签名者（或一组签名者）试图检查 block 中其他 signer 的提议(特别是投票踢出他们), 为了解决这个问题，我们将签名者的允许的挖矿频率限制在1/(N/2)。如果他不想被踢出出去, 就必须控制超过50%的signers.</li>
<li>“垃圾邮件”签名者(Spamming signer). 这些 signer 在每个他们签名的 block 中都注入一个新的投票提议.由于节点需要统计所有投票以创建授权签名者列表, 久而久之之后会产生大量垃圾的无用的投票, 导致系统运行变慢.通过 epoch 的机制,每次进入新的epoch都会丢弃旧的投票</li>
<li>并发块(Concurrent blocks). 如果授权签名者的数量为N，我们允许每个签名者签名是1/K，那么在任何时候，至少N-K个签名者都可以成功签名一个 block。为了避免这些 block 竞争( <strong>分叉</strong> )，每个签名者生成一个新 block 时都会加一点随机延时。这确保了很难发生分叉。</li>
</ul>
<h2 id="2-PoA共识引擎算法实现分析"><a href="#2-PoA共识引擎算法实现分析" class="headerlink" title="2. PoA共识引擎算法实现分析"></a>2. PoA共识引擎算法实现分析</h2><p>节点：普通的以太坊节点，没有区块生成的权利。</p>
<p>矿工：具有区块生成权利的以太坊节点</p>
<p>委员会：所有矿工的集合</p>
<h3 id="投票方法"><a href="#投票方法" class="headerlink" title="投票方法"></a>投票方法</h3><p>所有投票都是在委员生成新区块的过程中完成，具体流程如下：</p>
<ul>
<li>1）委员生成新区块时，先为该区块初始化一个 header。（prepare 方法，consensus/clique/clique.go）</li>
<li>2）从 proposals 中随机获取一个投票，将被投票的节点地址写入 header.coinbase，将提名是添加还是删除写入 header.Nonce (添加：0xffffffffffffffff 删除：0)，若该委员生成的这个区块最终被写入区块链，则header 中的投票也被写入区块链。（ prepare 方法，consensus/clique/clique.go）</li>
<li>3）委员在生成新区块时，会创建新的 snapshot，新的 snapshot 是由上一 checkponitinterval 时间点存储到数据库中的快照加入当前时间点和 checkpointinterval 时间点之间所有的 headers 数据组成。添加 header 过程中，若该 header 的 number 是 Epoch 时间点，则会将 snap 中的 Votes 和 Tally 两个集合清零。（apply方法，consensus/clique/snapshot.go）</li>
<li>4）新的 snapshot 添加 header 过程中，会检查每一个 header 中存储的投票，若该投票 snap.Votes 中已经存在，则将 snap.Votes 和 snap.Tally 两个集合的该投票删除。（apply 方法，consensus/clique/snapshot.）将每一个 header 中有效的提名写入新snapshot的snap.Votes和snap.Tally集合。（apply方法，consensus/clique/snapshot.go）</li>
<li>5）判断snap.Tally集合中某个被提名的节点，提名的次数是否大于snap.Signers的1/2,即是否有超过一半的委员对该节点进行投票，若超过，则投票成功，该节点会被添加到委员会或者从委员会中删除。（apply方法，consensus/clique/snapshot.go）</li>
</ul>
<p><strong>注释：snapshot 快照中的记录的委员会，即 Signers 集合，初始化时来源于创世块 header 中的 Extra</strong></p>
<h3 id="clique-中一些概念和定义"><a href="#clique-中一些概念和定义" class="headerlink" title="clique 中一些概念和定义"></a>clique 中一些概念和定义</h3><ul>
<li><strong>EPOCH_LENGTH</strong> : epoch 长度是30000个 block, 每次进入新的epoch,前面的投票都被清空,重新开始记录,这里的投票是指加入或移除signer</li>
<li><strong>CheckpointInterval</strong>：为常量1024（consensus/clique/clique.go中定义），即每当区块链的高度为1024的整数倍时，到达checkpointInterval时间点。</li>
<li><strong>BLOCK_PERIOD</strong> : 出块时间, 默认是15s</li>
<li><strong>UNCLE_HASH</strong> : 总是 <code>Keccak256(RLP([]))</code> ,因为没有uncle</li>
<li><strong>SIGNER_COUNT</strong> : 每个block都有一个signers的数量</li>
<li><strong>SIGNER_LIMIT</strong> : 等于 <code>(SIGNER_COUNT / 2) + 1</code><ul>
<li>每个singer只能签名连续SIGNER_LIMIT个block中的1个, 比如有5个signer:ABCDE, 对4个block进行签名, 不允许签名者为ABAC, 因为A在连续3个block中签名了2次</li>
</ul>
</li>
<li><strong>NONCE_AUTH</strong> : 表示投票类型是加入新的signer; 值= <code>0xffffffffffffffff</code></li>
<li><strong>NONCE_DROP</strong> : 表示投票类型是踢除旧的的signer; 值= <code>0x0000000000000000</code></li>
<li><strong>EXTRA_VANITY</strong> : 代表block头中Extra字段中的保留字段长度: 32字节</li>
<li><strong>EXTRA_SEAL</strong> : 代表block头中Extra字段中的存储签名数据的长度: 65字节</li>
<li><strong>IN-TURN/OUT-OF-TURN</strong> : 每个block都有一个in-turn的signer, 其他signers是out-of-turn, in-turn的signer的权重大一些, 出块的时间会快一点, 这样可以保证该高度的block被in-turn的signer挖到的概率很大.</li>
</ul>
<p>clique中最重要的两个数据结构:</p>
<ul>
<li>共识引擎的结构:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Clique <span class="keyword">struct</span> &#123;</div><div class="line">	config *params.CliqueConfig <span class="comment">// 系统配置参数</span></div><div class="line">	db ethdb.Database <span class="comment">// 数据库: 用于存取检查点快照</span></div><div class="line">	recents *lru.ARCCache <span class="comment">//保存最近block的快照, 加速reorgs</span></div><div class="line">	signatures *lru.ARCCache <span class="comment">//保存最近block的签名, 加速挖矿</span></div><div class="line">	proposals <span class="keyword">map</span>[common.Address]<span class="keyword">bool</span> <span class="comment">//当前signer提出的proposals列表</span></div><div class="line">	signer common.Address <span class="comment">// signer地址</span></div><div class="line">	signFn SignerFn <span class="comment">// 签名函数</span></div><div class="line">	lock sync.RWMutex <span class="comment">// 读写锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户通过RPC接口，调用Propose(address common.Address, auth bool)方法（consensus/clique/api.go）,进行投票，address表示要投票的节点的地址，auth表示要从将该地址加入委员会，还是从委员会中删除。</p>
<p>Propose 方法将 address 和 auth 两个输入参数写入到 clique.proposals 集合中。</p>
<p>任何一个委员会的委员，可以在任意时刻进行投票，投票包括两种，即加入委员会和从委员会中删除。</p>
<ul>
<li>snapshot的结构:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</div><div class="line">	config *params.CliqueConfig <span class="comment">// 系统配置参数</span></div><div class="line">	sigcache *lru.ARCCache <span class="comment">// 保存最近block的签名缓存,加速ecrecover</span></div><div class="line">	Number <span class="keyword">uint64</span> <span class="comment">// 创建快照时的block号,即生成快照时的区块链高度</span></div><div class="line">	Hash common.Hash <span class="comment">// 创建快照时的block hash</span></div><div class="line">	Signers <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 此刻的授权的signers</span></div><div class="line">	Recents <span class="keyword">map</span>[<span class="keyword">uint64</span>]common.Address <span class="comment">// 最近的一组signers, key=blockNumber</span></div><div class="line">	Votes []*Vote <span class="comment">// 按时间顺序排列的投票列表</span></div><div class="line">	Tally <span class="keyword">map</span>[common.Address]Tally <span class="comment">// 当前的投票计数，以避免重新计算，其中的Tally是该节点被投票的次数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Snapshot是一个快照，矿工程序在区块链高度为CheckpointInterval的整数倍时，会对当前相关数据和状态形成快照，并存储到数据库中。</p>
<p>除了这两个结构, 对block头的部分字段进行了复用定义, ethereum的block头定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</div><div class="line">	ParentHash common.Hash</div><div class="line">	UncleHash common.Hash</div><div class="line">	Coinbase common.Address</div><div class="line">	Root common.Hash</div><div class="line">	TxHash common.Hash</div><div class="line">	ReceiptHash common.Hash</div><div class="line">	Bloom Bloom</div><div class="line">	Difficulty *big.Int</div><div class="line">	Number *big.Int</div><div class="line">	GasLimit *big.Int</div><div class="line">	GasUsed *big.Int</div><div class="line">	Time *big.Int</div><div class="line">	Extra []<span class="keyword">byte</span></div><div class="line">	MixDigest common.Hash</div><div class="line">	Nonce BlockNonce</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创世块中的Extra字段包括:<ul>
<li>32字节的前缀(extraVanity)</li>
<li>所有signer的地址</li>
<li>65字节的后缀(extraSeal): 保存signer的签名</li>
</ul>
</li>
<li>其他block的Extra字段只包括extraVanity和extraSeal</li>
<li>Time字段表示产生block的时间间隔是:blockPeriod(15s)</li>
<li>Nonce字段表示进行一个投票: 添加( nonceAuthVote: <code>0xffffffffffffffff</code> )或者移除( nonceDropVote: <code>0x0000000000000000</code> )一个signer</li>
<li>Coinbase字段存放被投票的地址<ul>
<li>举个栗子: signerA的一个投票:加入signerB, 那么Coinbase存放B的地址</li>
</ul>
</li>
<li>Difficulty字段的值: 2-是 <strong>本block的签名者</strong> (in turn), 1- <strong>非本block的签名者</strong> (out of turn)</li>
</ul>
<p>POA共识算法中，委员会中的每一个矿工都会持续的生成新的区块，对于同一个Number的区块，不通的矿工生成该块时优先级不同。</p>
<p>优先级计算方法:</p>
<ul>
<li>Number:要生成的区块的块号</li>
<li>Signers：snapshot中记录的委员会集合，并根据矿工的地址进行了升序排列</li>
<li>Offset：矿工在Signers集合中的位置</li>
<li><p>若：(number % uint64(len(signers))) == uint64(offset)，则优先级最高，header. Difficulty =2;否则,header.Difficulty = 1</p>
<p>总结如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段</th>
<th>POW</th>
<th>POA</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Coinbase</td>
<td>挖矿奖励地址</td>
<td>被提名为矿工的节点地址</td>
</tr>
<tr>
<td>2</td>
<td>Nonce</td>
<td>随机数</td>
<td>提名分类，添加或删除</td>
</tr>
<tr>
<td>3</td>
<td>Extra</td>
<td>其他数据</td>
<td>在Epoch时间点，存储当前委员会集合Signers</td>
</tr>
<tr>
<td>4</td>
<td>Difficulty</td>
<td>挖矿难度</td>
<td>优先级</td>
</tr>
<tr>
<td>5</td>
<td>Time</td>
<td>产生block的时间</td>
<td>产生block的时间间隔</td>
</tr>
</tbody>
</table>
<p>下面对比较重要的函数详细分析实现流程</p>
<h4 id="共识引擎-clique-的初始化"><a href="#共识引擎-clique-的初始化" class="headerlink" title="共识引擎 clique 的初始化"></a>共识引擎 clique 的初始化</h4><p>在 <code>Ethereum.StartMining</code> 中,如果Ethereum.engine配置为clique.Clique, 根据当前节点的矿工地址(默认是acounts[0]), 配置clique的 <strong>签名者</strong> : <code>clique.Authorize(eb, wallet.SignHash)</code> ,其中 <strong>签名函数</strong> 是SignHash,对给定的hash进行签名.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// New creates a Clique proof-of-authority consensus engine with the initial</span></div><div class="line"><span class="comment">// signers set to the ones provided by the user.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(config *params.CliqueConfig, db ethdb.Database)</span> *<span class="title">Clique</span></span> &#123;</div><div class="line">	<span class="comment">// Set any missing consensus parameters to their defaults</span></div><div class="line">	conf := *config</div><div class="line">	<span class="keyword">if</span> conf.Epoch == <span class="number">0</span> &#123;</div><div class="line">		conf.Epoch = epochLength</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Allocate the snapshot caches and create the engine</span></div><div class="line">	recents, _ := lru.NewARC(inmemorySnapshots)</div><div class="line">	signatures, _ := lru.NewARC(inmemorySignatures)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &amp;Clique&#123;</div><div class="line">		config:     &amp;conf,</div><div class="line">		db:         db,</div><div class="line">		recents:    recents,</div><div class="line">		signatures: signatures,</div><div class="line">		proposals:  <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">bool</span>),</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Clique-Prepare-chain-header"><a href="#Clique-Prepare-chain-header" class="headerlink" title="Clique.Prepare(chain , header)"></a>Clique.Prepare(chain , header)</h4><p>Prepare是共识引擎接口之一. 该函数配置header中共识相关的参数(Cionbase, Difficulty, Extra, MixDigest, Time)</p>
<ul>
<li>对于非epoch的block( <code>number % Epoch != 0</code> ):</li>
</ul>
<ol>
<li>得到Clique.proposals中的投票数据(例:A加入C, B踢除D)</li>
<li>根据snapshot的signers分析投票数否有效(例: C原先没有在signers中, 加入投票有效, D原先在signers中,踢除投票有效)</li>
<li>从被投票的地址列表(C,D)中, <strong>随机选择一个地址</strong> ,作为该header的Coinbase,设置Nonce为加入( <code>0xffffffffffffffff</code> )或者踢除( <code>0x0000000000000000</code> )</li>
<li><code>Clique.signer</code> 如果是本轮的签名者(in-turn), 设置header.Difficulty = diffInTurn(2), 否则就是diffNoTurn(1)</li>
<li>配置header.Extra的数据为[ <code>extraVanity</code> + <code>snap中的全部signers</code> + <code>extraSeal</code> ]</li>
<li>MixDigest需要配置为nil</li>
<li>配置时间戳:Time为父块的时间+15s</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Prepare implements consensus.Engine, preparing all the consensus fields of the</span></div><div class="line"><span class="comment">// header for running the transactions on top.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">Prepare</span><span class="params">(chain consensus.ChainReader, header *types.Header)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// If the block isn't a checkpoint, cast a random vote (good enough for now)</span></div><div class="line">	header.Coinbase = common.Address&#123;&#125;</div><div class="line">	header.Nonce = types.BlockNonce&#123;&#125;</div><div class="line"></div><div class="line">	number := header.Number.Uint64()</div><div class="line">	<span class="comment">// Assemble the voting snapshot to check which votes make sense</span></div><div class="line">	snap, err := c.snapshot(chain, number<span class="number">-1</span>, header.ParentHash, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> number%c.config.Epoch != <span class="number">0</span> &#123;</div><div class="line">		c.lock.RLock()</div><div class="line"></div><div class="line">		<span class="comment">// Gather all the proposals that make sense voting on</span></div><div class="line">		addresses := <span class="built_in">make</span>([]common.Address, <span class="number">0</span>, <span class="built_in">len</span>(c.proposals))</div><div class="line">		<span class="keyword">for</span> address, authorize := <span class="keyword">range</span> c.proposals &#123;</div><div class="line">			<span class="keyword">if</span> snap.validVote(address, authorize) &#123;</div><div class="line">				addresses = <span class="built_in">append</span>(addresses, address)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If there's pending proposals, cast a vote on them</span></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(addresses) &gt; <span class="number">0</span> &#123;</div><div class="line">			header.Coinbase = addresses[rand.Intn(<span class="built_in">len</span>(addresses))]</div><div class="line">			<span class="keyword">if</span> c.proposals[header.Coinbase] &#123;</div><div class="line">				<span class="built_in">copy</span>(header.Nonce[:], nonceAuthVote)</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">copy</span>(header.Nonce[:], nonceDropVote)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		c.lock.RUnlock()</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Set the correct difficulty</span></div><div class="line">	header.Difficulty = CalcDifficulty(snap, c.signer)</div><div class="line"></div><div class="line">	<span class="comment">// Ensure the extra data has all it's components</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(header.Extra) &lt; extraVanity &#123;</div><div class="line">		header.Extra = <span class="built_in">append</span>(header.Extra, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0x00</span>&#125;, extraVanity-<span class="built_in">len</span>(header.Extra))...)</div><div class="line">	&#125;</div><div class="line">	header.Extra = header.Extra[:extraVanity]</div><div class="line"></div><div class="line">	<span class="keyword">if</span> number%c.config.Epoch == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">for</span> _, signer := <span class="keyword">range</span> snap.signers() &#123;</div><div class="line">			header.Extra = <span class="built_in">append</span>(header.Extra, signer[:]...)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	header.Extra = <span class="built_in">append</span>(header.Extra, <span class="built_in">make</span>([]<span class="keyword">byte</span>, extraSeal)...)</div><div class="line"></div><div class="line">	<span class="comment">// Mix digest is reserved for now, set to empty</span></div><div class="line">	header.MixDigest = common.Hash&#123;&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Ensure the timestamp has the correct delay</span></div><div class="line">	parent := chain.GetHeader(header.ParentHash, number<span class="number">-1</span>)</div><div class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> consensus.ErrUnknownAncestor</div><div class="line">	&#125;</div><div class="line">	header.Time = <span class="built_in">new</span>(big.Int).Add(parent.Time, <span class="built_in">new</span>(big.Int).SetUint64(c.config.Period))</div><div class="line">	<span class="keyword">if</span> header.Time.Int64() &lt; time.Now().Unix() &#123;</div><div class="line">		header.Time = big.NewInt(time.Now().Unix())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取给定时间点的一个快照-Clique-snapshot"><a href="#获取给定时间点的一个快照-Clique-snapshot" class="headerlink" title="获取给定时间点的一个快照 Clique.snapshot"></a>获取给定时间点的一个快照 Clique.snapshot</h4><ul>
<li><p>先查找 Clique.recents 中是否有缓存, 有的话就返回该 snapshot</p>
</li>
<li><p>在查找持久化存储中是否有缓存, 有的话就返回该 snapshot</p>
</li>
<li><p>如果是创世块</p>
<ol>
<li>从 Extra 中取出所有的 signers</li>
<li><code>newSnapshot(Clique.config, Clique.signatures, 0, genesis.Hash(), signers)</code></li>
</ol>
<ul>
<li>signatures 是最近的签名快照</li>
<li>signers 是所有的初始 signers</li>
</ul>
<p>把 snapshot 加入到 Clique.recents 中, 并持久化到 db 中</p>
</li>
<li><p>其他普通块</p>
<ul>
<li>沿着父块 hash 一直往回找是否有 snapshot, 如果没找到就记录该区块头</li>
<li>如果找到最近的 snapshot, 将前面记录的 headers 都 <code>applay</code> 到该 snapshot 上</li>
<li>保存该最新的 snapshot 到缓存 Clique.recents 中, 并持久化到 db 中</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// snapshot retrieves the authorization snapshot at a given point in time.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">snapshot</span><span class="params">(chain consensus.ChainReader, number <span class="keyword">uint64</span>, hash common.Hash, parents []*types.Header)</span> <span class="params">(*Snapshot, error)</span></span> &#123;</div><div class="line">	<span class="comment">// Search for a snapshot in memory or on disk for checkpoints</span></div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		headers []*types.Header</div><div class="line">		snap    *Snapshot</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> snap == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// If an in-memory snapshot was found, use that</span></div><div class="line">		<span class="keyword">if</span> s, ok := c.recents.Get(hash); ok &#123;</div><div class="line">			snap = s.(*Snapshot)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If an on-disk checkpoint snapshot can be found, use that</span></div><div class="line">		<span class="keyword">if</span> number%checkpointInterval == <span class="number">0</span> &#123;</div><div class="line">			<span class="keyword">if</span> s, err := loadSnapshot(c.config, c.signatures, c.db, hash); err == <span class="literal">nil</span> &#123;</div><div class="line">				log.Trace(<span class="string">"Loaded voting snapshot form disk"</span>, <span class="string">"number"</span>, number, <span class="string">"hash"</span>, hash)</div><div class="line">				snap = s</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If we're at block zero, make a snapshot</span></div><div class="line">		<span class="keyword">if</span> number == <span class="number">0</span> &#123;</div><div class="line">			genesis := chain.GetHeaderByNumber(<span class="number">0</span>)</div><div class="line">			<span class="keyword">if</span> err := c.VerifyHeader(chain, genesis, <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			signers := <span class="built_in">make</span>([]common.Address, (<span class="built_in">len</span>(genesis.Extra)-extraVanity-extraSeal)/common.AddressLength)</div><div class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(signers); i++ &#123;</div><div class="line">				<span class="built_in">copy</span>(signers[i][:], genesis.Extra[extraVanity+i*common.AddressLength:])</div><div class="line">			&#125;</div><div class="line">			snap = newSnapshot(c.config, c.signatures, <span class="number">0</span>, genesis.Hash(), signers)</div><div class="line">			<span class="keyword">if</span> err := snap.store(c.db); err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">			&#125;</div><div class="line">			log.Trace(<span class="string">"Stored genesis voting snapshot to disk"</span>)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// No snapshot for this header, gather the header and move backward</span></div><div class="line">		<span class="keyword">var</span> header *types.Header</div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(parents) &gt; <span class="number">0</span> &#123;</div><div class="line">			<span class="comment">// If we have explicit parents, pick from there (enforced)</span></div><div class="line">			header = parents[<span class="built_in">len</span>(parents)<span class="number">-1</span>]</div><div class="line">			<span class="keyword">if</span> header.Hash() != hash || header.Number.Uint64() != number &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, consensus.ErrUnknownAncestor</div><div class="line">			&#125;</div><div class="line">			parents = parents[:<span class="built_in">len</span>(parents)<span class="number">-1</span>]</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// No explicit parents (or no more left), reach out to the database</span></div><div class="line">			header = chain.GetHeader(hash, number)</div><div class="line">			<span class="keyword">if</span> header == <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, consensus.ErrUnknownAncestor</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		headers = <span class="built_in">append</span>(headers, header)</div><div class="line">		number, hash = number<span class="number">-1</span>, header.ParentHash</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Previous snapshot found, apply any pending headers on top of it</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(headers)/<span class="number">2</span>; i++ &#123;</div><div class="line">		headers[i], headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>-i] = headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>-i], headers[i]</div><div class="line">	&#125;</div><div class="line">	snap, err := snap.apply(headers)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	c.recents.Add(snap.Hash, snap)</div><div class="line"></div><div class="line">	<span class="comment">// If we've generated a new checkpoint snapshot, save to disk</span></div><div class="line">	<span class="keyword">if</span> snap.Number%checkpointInterval == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">if</span> err = snap.store(c.db); err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		log.Trace(<span class="string">"Stored voting snapshot to disk"</span>, <span class="string">"number"</span>, snap.Number, <span class="string">"hash"</span>, snap.Hash)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> snap, err</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Snapshot-apply-headers"><a href="#Snapshot-apply-headers" class="headerlink" title="Snapshot.apply(headers)"></a>Snapshot.apply(headers)</h4><p>创建一个新的授权signers的快照, 将从上一个snapshot开始的区块头中的proposals更新到最新的snapshot上</p>
<ol>
<li>对入参headers进行完整性检查: 因为可能传入多个区块头, <strong>block号必须连续</strong></li>
<li>遍历所有的header, 如果block号刚好处于epoch的起始(number%Epoch == 0),将snapshot中的Votes和Tally复位( <strong>丢弃历史全部数据</strong> )</li>
<li>对于每一个header,从签名中恢复得到 <strong>signer</strong></li>
<li>如果该signer在snap.Recents中, 说明 <strong>最近已经有过签名</strong> , 不允许再次签名, 直接 <strong>返回</strong> 结束</li>
<li>记录该signer最近已经有过签名，且是该block的签名者: <code>snap.Recents[number] = signer</code></li>
<li>统计header.Coinbase的投票数,如果超过signers总数的50%，执行加入或移除操作</li>
<li>删除snap.Recents中的一个signer记录: key=number- (uint64(len(snap.Signers)/2 + 1)), 表示释放该signer,下次可以对block进行签名了</li>
<li>清空被移除的Coinbase的投票</li>
<li>移除snap.Votes中该Conibase的所有投票记录</li>
<li>移除snap.Tally中该Conibase的所有投票数记录</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// apply creates a new authorization snapshot by applying the given headers to</span></div><div class="line"><span class="comment">// the original one.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Snapshot)</span> <span class="title">apply</span><span class="params">(headers []*types.Header)</span> <span class="params">(*Snapshot, error)</span></span> &#123;</div><div class="line">	<span class="comment">// Allow passing in no headers for cleaner code</span></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> s, <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Sanity check that the headers can be applied</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(headers)<span class="number">-1</span>; i++ &#123;</div><div class="line">		<span class="keyword">if</span> headers[i+<span class="number">1</span>].Number.Uint64() != headers[i].Number.Uint64()+<span class="number">1</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errInvalidVotingChain</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> headers[<span class="number">0</span>].Number.Uint64() != s.Number+<span class="number">1</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errInvalidVotingChain</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Iterate through the headers and create a new snapshot</span></div><div class="line">	snap := s.<span class="built_in">copy</span>()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> headers &#123;</div><div class="line">		<span class="comment">// Remove any votes on checkpoint blocks</span></div><div class="line">		number := header.Number.Uint64()</div><div class="line">		<span class="keyword">if</span> number%s.config.Epoch == <span class="number">0</span> &#123;</div><div class="line">			snap.Votes = <span class="literal">nil</span></div><div class="line">			snap.Tally = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]Tally)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Delete the oldest signer from the recent list to allow it signing again</span></div><div class="line">		<span class="keyword">if</span> limit := <span class="keyword">uint64</span>(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> + <span class="number">1</span>); number &gt;= limit &#123;</div><div class="line">			<span class="built_in">delete</span>(snap.Recents, number-limit)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Resolve the authorization key and check against signers</span></div><div class="line">		signer, err := ecrecover(header, s.sigcache)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> _, ok := snap.Signers[signer]; !ok &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errUnauthorized</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> _, recent := <span class="keyword">range</span> snap.Recents &#123;</div><div class="line">			<span class="keyword">if</span> recent == signer &#123;</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errUnauthorized</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		snap.Recents[number] = signer</div><div class="line"></div><div class="line">		<span class="comment">// Header authorized, discard any previous votes from the signer</span></div><div class="line">		<span class="keyword">for</span> i, vote := <span class="keyword">range</span> snap.Votes &#123;</div><div class="line">			<span class="keyword">if</span> vote.Signer == signer &amp;&amp; vote.Address == header.Coinbase &#123;</div><div class="line">				<span class="comment">// Uncast the vote from the cached tally</span></div><div class="line">				snap.uncast(vote.Address, vote.Authorize)</div><div class="line"></div><div class="line">				<span class="comment">// Uncast the vote from the chronological list</span></div><div class="line">				snap.Votes = <span class="built_in">append</span>(snap.Votes[:i], snap.Votes[i+<span class="number">1</span>:]...)</div><div class="line">				<span class="keyword">break</span> <span class="comment">// only one vote allowed</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// Tally up the new vote from the signer</span></div><div class="line">		<span class="keyword">var</span> authorize <span class="keyword">bool</span></div><div class="line">		<span class="keyword">switch</span> &#123;</div><div class="line">		<span class="keyword">case</span> bytes.Equal(header.Nonce[:], nonceAuthVote):</div><div class="line">			authorize = <span class="literal">true</span></div><div class="line">		<span class="keyword">case</span> bytes.Equal(header.Nonce[:], nonceDropVote):</div><div class="line">			authorize = <span class="literal">false</span></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errInvalidVote</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> snap.cast(header.Coinbase, authorize) &#123;</div><div class="line">			snap.Votes = <span class="built_in">append</span>(snap.Votes, &amp;Vote&#123;</div><div class="line">				Signer:    signer,</div><div class="line">				Block:     number,</div><div class="line">				Address:   header.Coinbase,</div><div class="line">				Authorize: authorize,</div><div class="line">			&#125;)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// If the vote passed, update the list of signers</span></div><div class="line">		<span class="keyword">if</span> tally := snap.Tally[header.Coinbase]; tally.Votes &gt; <span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> &#123;</div><div class="line">			<span class="keyword">if</span> tally.Authorize &#123;</div><div class="line">				snap.Signers[header.Coinbase] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="built_in">delete</span>(snap.Signers, header.Coinbase)</div><div class="line"></div><div class="line">				<span class="comment">// Signer list shrunk, delete any leftover recent caches</span></div><div class="line">				<span class="keyword">if</span> limit := <span class="keyword">uint64</span>(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> + <span class="number">1</span>); number &gt;= limit &#123;</div><div class="line">					<span class="built_in">delete</span>(snap.Recents, number-limit)</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Discard any previous votes the deauthorized signer cast</span></div><div class="line">				<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(snap.Votes); i++ &#123;</div><div class="line">					<span class="keyword">if</span> snap.Votes[i].Signer == header.Coinbase &#123;</div><div class="line">						<span class="comment">// Uncast the vote from the cached tally</span></div><div class="line">						snap.uncast(snap.Votes[i].Address, snap.Votes[i].Authorize)</div><div class="line"></div><div class="line">						<span class="comment">// Uncast the vote from the chronological list</span></div><div class="line">						snap.Votes = <span class="built_in">append</span>(snap.Votes[:i], snap.Votes[i+<span class="number">1</span>:]...)</div><div class="line"></div><div class="line">						i--</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Discard any previous votes around the just changed account</span></div><div class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(snap.Votes); i++ &#123;</div><div class="line">				<span class="keyword">if</span> snap.Votes[i].Address == header.Coinbase &#123;</div><div class="line">					snap.Votes = <span class="built_in">append</span>(snap.Votes[:i], snap.Votes[i+<span class="number">1</span>:]...)</div><div class="line">					i--</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="built_in">delete</span>(snap.Tally, header.Coinbase)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	snap.Number += <span class="keyword">uint64</span>(<span class="built_in">len</span>(headers))</div><div class="line">	snap.Hash = headers[<span class="built_in">len</span>(headers)<span class="number">-1</span>].Hash()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> snap, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Clique-Seal-chain-block-stop"><a href="#Clique-Seal-chain-block-stop" class="headerlink" title="Clique.Seal(chain, block , stop)"></a>Clique.Seal(chain, block , stop)</h4><p>Seal也是共识引擎接口之一. 该函数用clique.signer对block的进行签名. 在pow算法中, 该函数进行hash运算来解”难题”.</p>
<ul>
<li>如果signer没有在snapshot的signers中,不允许对block进行签名</li>
<li>如果不是本block的签名者,延时一定的时间(随机)后再签名, 如果是本block的签名者, 立即签名.</li>
<li>签名结果放在Extra的extraSeal的65字节中</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Seal implements consensus.Engine, attempting to create a sealed block using</span></div><div class="line"><span class="comment">// the local signing credentials.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">Seal</span><span class="params">(chain consensus.ChainReader, block *types.Block, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="params">(*types.Block, error)</span></span> &#123;</div><div class="line">	header := block.Header()</div><div class="line"></div><div class="line">	<span class="comment">// Sealing the genesis block is not supported</span></div><div class="line">	number := header.Number.Uint64()</div><div class="line">	<span class="keyword">if</span> number == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errUnknownBlock</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// For 0-period chains, refuse to seal empty blocks (no reward but would spin sealing)</span></div><div class="line">	<span class="keyword">if</span> c.config.Period == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(block.Transactions()) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errWaitTransactions</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Don't hold the signer fields for the entire sealing procedure</span></div><div class="line">	c.lock.RLock()</div><div class="line">	signer, signFn := c.signer, c.signFn</div><div class="line">	c.lock.RUnlock()</div><div class="line"></div><div class="line">	<span class="comment">// Bail out if we're unauthorized to sign a block</span></div><div class="line">	snap, err := c.snapshot(chain, number<span class="number">-1</span>, header.ParentHash, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> _, authorized := snap.Signers[signer]; !authorized &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errUnauthorized</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// If we're amongst the recent signers, wait for the next block</span></div><div class="line">	<span class="keyword">for</span> seen, recent := <span class="keyword">range</span> snap.Recents &#123;</div><div class="line">		<span class="keyword">if</span> recent == signer &#123;</div><div class="line">			<span class="comment">// Signer is among recents, only wait if the current block doesn't shift it out</span></div><div class="line">			<span class="keyword">if</span> limit := <span class="keyword">uint64</span>(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> + <span class="number">1</span>); number &lt; limit || seen &gt; number-limit &#123;</div><div class="line">				log.Info(<span class="string">"Signed recently, must wait for others"</span>)</div><div class="line">				&lt;-stop</div><div class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Sweet, the protocol permits us to sign the block, wait for our time</span></div><div class="line">	delay := time.Unix(header.Time.Int64(), <span class="number">0</span>).Sub(time.Now()) <span class="comment">// nolint: gosimple</span></div><div class="line">	<span class="keyword">if</span> header.Difficulty.Cmp(diffNoTurn) == <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// It's not our turn explicitly to sign, delay it a bit</span></div><div class="line">		wiggle := time.Duration(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span>+<span class="number">1</span>) * wiggleTime</div><div class="line">		delay += time.Duration(rand.Int63n(<span class="keyword">int64</span>(wiggle)))</div><div class="line"></div><div class="line">		log.Trace(<span class="string">"Out-of-turn signing requested"</span>, <span class="string">"wiggle"</span>, common.PrettyDuration(wiggle))</div><div class="line">	&#125;</div><div class="line">	log.Trace(<span class="string">"Waiting for slot to sign and propagate"</span>, <span class="string">"delay"</span>, common.PrettyDuration(delay))</div><div class="line"></div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> &lt;-stop:</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></div><div class="line">	<span class="keyword">case</span> &lt;-time.After(delay):</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Sign all the things!</span></div><div class="line">	sighash, err := signFn(accounts.Account&#123;Address: signer&#125;, sigHash(header).Bytes())</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">copy</span>(header.Extra[<span class="built_in">len</span>(header.Extra)-extraSeal:], sighash)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> block.WithSeal(header), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Clique-VerifySeal-chain-header"><a href="#Clique-VerifySeal-chain-header" class="headerlink" title="Clique.VerifySeal(chain, header)"></a>Clique.VerifySeal(chain, header)</h4><p>VerifySeal也是共识引擎接口之一.</p>
<ol>
<li>从header的签名中恢复账户地址,改地址要求在snapshot的signers中</li>
<li>检查header中的Difficulty是否匹配(in turn或out of turn)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// VerifySeal implements consensus.Engine, checking whether the signature contained</span></div><div class="line"><span class="comment">// in the header satisfies the consensus protocol requirements.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">VerifySeal</span><span class="params">(chain consensus.ChainReader, header *types.Header)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> c.verifySeal(chain, header, <span class="literal">nil</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// verifySeal checks whether the signature contained in the header satisfies the</span></div><div class="line"><span class="comment">// consensus protocol requirements. The method accepts an optional list of parent</span></div><div class="line"><span class="comment">// headers that aren't yet part of the local blockchain to generate the snapshots</span></div><div class="line"><span class="comment">// from.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">verifySeal</span><span class="params">(chain consensus.ChainReader, header *types.Header, parents []*types.Header)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">// Verifying the genesis block is not supported</span></div><div class="line">	number := header.Number.Uint64()</div><div class="line">	<span class="keyword">if</span> number == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> errUnknownBlock</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Retrieve the snapshot needed to verify this header and cache it</span></div><div class="line">	snap, err := c.snapshot(chain, number<span class="number">-1</span>, header.ParentHash, parents)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Resolve the authorization key and check against signers</span></div><div class="line">	signer, err := ecrecover(header, c.signatures)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> _, ok := snap.Signers[signer]; !ok &#123;</div><div class="line">		<span class="keyword">return</span> errUnauthorized</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> seen, recent := <span class="keyword">range</span> snap.Recents &#123;</div><div class="line">		<span class="keyword">if</span> recent == signer &#123;</div><div class="line">			<span class="comment">// Signer is among recents, only fail if the current block doesn't shift it out</span></div><div class="line">			<span class="keyword">if</span> limit := <span class="keyword">uint64</span>(<span class="built_in">len</span>(snap.Signers)/<span class="number">2</span> + <span class="number">1</span>); seen &gt; number-limit &#123;</div><div class="line">				<span class="keyword">return</span> errUnauthorized</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Ensure that the difficulty corresponds to the turn-ness of the signer</span></div><div class="line">	inturn := snap.inturn(header.Number.Uint64(), signer)</div><div class="line">	<span class="keyword">if</span> inturn &amp;&amp; header.Difficulty.Cmp(diffInTurn) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> errInvalidDifficulty</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> !inturn &amp;&amp; header.Difficulty.Cmp(diffNoTurn) != <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> errInvalidDifficulty</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Clique-Finalize"><a href="#Clique-Finalize" class="headerlink" title="Clique.Finalize"></a>Clique.Finalize</h4><p>Finalize也是共识引擎接口之一. 该函数生成一个block, 没有叔块处理,也没有奖励机制</p>
<ol>
<li><code>header.Root</code> : 状态根保持原状</li>
<li><code>header.UncleHash</code> : 为nil</li>
<li><code>types.NewBlock(header, txs, nil, receipts)</code> : 封装并返回最终的block</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Finalize implements consensus.Engine, ensuring no uncles are set, nor block</span></div><div class="line"><span class="comment">// rewards given, and returns the final block.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clique)</span> <span class="title">Finalize</span><span class="params">(chain consensus.ChainReader, header *types.Header, state *state.StateDB, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt)</span> <span class="params">(*types.Block, error)</span></span> &#123;</div><div class="line">	<span class="comment">// No block rewards in PoA, so the state remains as is and uncles are dropped</span></div><div class="line">	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))</div><div class="line">	header.UncleHash = types.CalcUncleHash(<span class="literal">nil</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Assemble and return the final block for sealing</span></div><div class="line">	<span class="keyword">return</span> types.NewBlock(header, txs, <span class="literal">nil</span>, receipts), <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="API-Propose-addr-auth"><a href="#API-Propose-addr-auth" class="headerlink" title="API.Propose(addr, auth)"></a>API.Propose(addr, auth)</h4><p>添加一个proposal: 调用者对addr的投票, auth表示加入还是踢出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Propose injects a new authorization proposal that the signer will attempt to</span></div><div class="line"><span class="comment">// push through.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">Propose</span><span class="params">(address common.Address, auth <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">	api.clique.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> api.clique.lock.Unlock()</div><div class="line"></div><div class="line">	api.clique.proposals[address] = auth</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="API-Discard-addr"><a href="#API-Discard-addr" class="headerlink" title="API.Discard(addr)"></a>API.Discard(addr)</h4><p>删除一个proposal</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Discard drops a currently running proposal, stopping the signer from casting</span></div><div class="line"><span class="comment">// further votes (either for or against).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">Discard</span><span class="params">(address common.Address)</span></span> &#123;</div><div class="line">	api.clique.lock.Lock()</div><div class="line">	<span class="keyword">defer</span> api.clique.lock.Unlock()</div><div class="line"></div><div class="line">	<span class="built_in">delete</span>(api.clique.proposals, address)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/BlockChain/">BlockChain</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/BlockChain/">BlockChain</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yangchenglong11.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/BlockChain/">BlockChain</a><small>7</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>15</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/categories/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/categories/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/04/10/PoA/">PoA</a>
      </li>
    
      <li>
        <a href="/2018/03/26/mine/">mine</a>
      </li>
    
      <li>
        <a href="/2018/03/18/the-store-of-block/">区块存储</a>
      </li>
    
      <li>
        <a href="/2018/03/16/merkle-patricia-tree/">Merkle Patricia Tree (梅克尔帕特里夏树) 详解</a>
      </li>
    
      <li>
        <a href="/2018/03/13/the-basic-of-ethereum/">初识以太坊</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BlockChain/">BlockChain</a><small>7</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/tags/Golang/">Golang</a><small>16</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/tags/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BlockChain/" style="font-size: 17.5px;">BlockChain</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 12.5px;">MongoDB</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 Yang Chenglong
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="300" height="400" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -50px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/tororo/tororo.model.json",0.5)</script>
  
</body>
</html>