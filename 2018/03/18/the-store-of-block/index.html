<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>区块存储 | yangcl&#39;s</title>
  <meta name="author" content="Yang Chenglong" />

  
  <meta name="description" content="Yangcl&#39;s Blog" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="区块存储" />
  <meta property="og:site_name" content="yangcl&#39;s" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="yangcl&#39;s" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">yangcl&#39;s</a></h1>
  <h2><a href="/">悟已往之不谏，知来者之可追。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
      <li><a href="https://github.com/yangchenglong11">github</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-03-18T04:42:40.000Z"><a href="/2018/03/18/the-store-of-block/">2018-03-18</a></time>
      
      
  
    <h1 class="title">区块存储</h1>
  

    </header>
    <div class="entry">
      
        <p>区块(Block)是以太坊的核心数据结构之一，Block包含Header和Body两部分。区块的存储是由leveldb完成的，leveldb的数据是以键值对存储的。<br><a id="more"></a><br><img src="/2018/03/18/the-store-of-block/core_data_structure.png" alt="data_structure"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BlockChain 表示了一个规范的链,这个链通过一个包含了创世区块的数据库指定. BlockChain管理了链的插入,还原,重建等操作.</span></div><div class="line"><span class="comment">// 插入一个区块需要通过一系列指定的规则指定的两阶段的验证器.</span></div><div class="line"><span class="comment">// 使用Processor来对区块的交易进行处理. 状态的验证是第二阶段的验证器. 错误将导致插入终止.</span></div><div class="line"><span class="comment">// 需要注意的是GetBlock可能返回任意不在当前规范区块链中的区块,</span></div><div class="line"><span class="comment">// 但是GetBlockByNumber总是返回当前规范区块链中的区块.</span></div><div class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</div><div class="line">    chainConfig *params.ChainConfig <span class="comment">// Chain &amp; network configuration</span></div><div class="line">    cacheConfig *CacheConfig        <span class="comment">// Cache configuration for pruning</span></div><div class="line"></div><div class="line">    db     ethdb.Database <span class="comment">// Low level persistent database to store final content in</span></div><div class="line">    triegc *prque.Prque   <span class="comment">// Priority queue mapping block numbers to tries to gc</span></div><div class="line">    gcproc time.Duration  <span class="comment">// Accumulates canonical block processing for trie dumping</span></div><div class="line"></div><div class="line">    hc            *HeaderChain <span class="comment">// 只包含了区块头的区块链</span></div><div class="line">    rmLogsFeed    event.Feed   <span class="comment">// 底层数据库</span></div><div class="line">    chainFeed     event.Feed   <span class="comment">// 下面是很多消息通知的组件</span></div><div class="line">    chainSideFeed event.Feed</div><div class="line">    chainHeadFeed event.Feed</div><div class="line">    logsFeed      event.Feed</div><div class="line">    scope         event.SubscriptionScope</div><div class="line">    genesisBlock  *types.Block  <span class="comment">// 创世区块</span></div><div class="line"></div><div class="line">    mu      sync.RWMutex <span class="comment">// global mutex for locking chain operations</span></div><div class="line">    chainmu sync.RWMutex <span class="comment">// blockchain insertion lock</span></div><div class="line">    procmu  sync.RWMutex <span class="comment">// block processor lock</span></div><div class="line"></div><div class="line">    checkpoint       <span class="keyword">int</span>          <span class="comment">// checkpoint counts towards the new checkpoint</span></div><div class="line">    currentBlock     *types.Block <span class="comment">// Current head of the block chain 当前的区块头</span></div><div class="line">    currentFastBlock *types.Block <span class="comment">// Current head of the fast-sync chain (may be above the block chain!) 当前的快速同步的区块头</span></div><div class="line"></div><div class="line">    stateCache   state.Database <span class="comment">// State database to reuse between imports (contains state cache)</span></div><div class="line">    bodyCache    *lru.Cache     <span class="comment">// Cache for the most recent block bodies</span></div><div class="line">    bodyRLPCache *lru.Cache     <span class="comment">// Cache for the most recent block bodies in RLP encoded format</span></div><div class="line">    blockCache   *lru.Cache     <span class="comment">// Cache for the most recent entire blocks</span></div><div class="line">    futureBlocks *lru.Cache     <span class="comment">// future blocks are blocks added for later processing 暂时还不能插入的区块存放位置</span></div><div class="line"></div><div class="line">    quit    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// blockchain quit channel</span></div><div class="line">    running <span class="keyword">int32</span>         <span class="comment">// running must be called atomically</span></div><div class="line">    <span class="comment">// procInterrupt must be atomically called</span></div><div class="line">    procInterrupt <span class="keyword">int32</span>          <span class="comment">// interrupt signaler for block processing</span></div><div class="line">    wg            sync.WaitGroup <span class="comment">// chain processing wait group for shutting down</span></div><div class="line"></div><div class="line">    engine    consensus.Engine  <span class="comment">// 一致性引擎</span></div><div class="line">    processor Processor <span class="comment">// block processor interface    // 区块处理器接口</span></div><div class="line">    validator Validator <span class="comment">// block and state validator interface // 区块和状态验证器接口</span></div><div class="line">    vmConfig  vm.Config <span class="comment">// 虚拟机的配置</span></div><div class="line"></div><div class="line">    badBlocks *lru.Cache <span class="comment">// Bad block cache 错误区块的缓存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> Blockchain管理所有的Block, 让其组成一个单向链表。Headerchain管理所有的Header,也形成一个单向链表， Headerchain是Blockchain里面的一部分  。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> HeaderChain <span class="keyword">struct</span> &#123;</div><div class="line">	config *params.ChainConfig</div><div class="line"></div><div class="line">	chainDb       ethdb.Database</div><div class="line">	genesisHeader *types.Header</div><div class="line"></div><div class="line">	currentHeader     atomic.Value <span class="comment">// Current head of the header chain (may be above the block chain!)</span></div><div class="line">	currentHeaderHash common.Hash  <span class="comment">// Hash of the current head of the header chain (prevent recomputing all the time)</span></div><div class="line"></div><div class="line">	headerCache *lru.Cache <span class="comment">// Cache for the most recent block headers</span></div><div class="line">	tdCache     *lru.Cache <span class="comment">// Cache for the most recent block total difficulties</span></div><div class="line">	numberCache *lru.Cache <span class="comment">// Cache for the most recent block numbers</span></div><div class="line"></div><div class="line">	procInterrupt <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">	<span class="title">rand</span>   *<span class="title">mrand</span>.<span class="title">Rand</span></span></div><div class="line"><span class="function">	<span class="title">engine</span> <span class="title">consensus</span>.<span class="title">Engine</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure>
<p>以太坊的数据库体系-Merkle-Patricia Trie(MPT)， 它是由一系列节点组成的二叉树，在树底包含了源数据的大量叶子节点， 父节点是两个子节点的Hash值，一直到根节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Header represents a block header in the Ethereum blockchain.</span></div><div class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</div><div class="line">   ParentHash  common.Hash    <span class="string">`json:"parentHash"       gencodec:"required"`</span></div><div class="line">   UncleHash   common.Hash    <span class="string">`json:"sha3Uncles"       gencodec:"required"`</span></div><div class="line">   Coinbase    common.Address <span class="string">`json:"miner"            gencodec:"required"`</span></div><div class="line">   Root        common.Hash    <span class="string">`json:"stateRoot"        gencodec:"required"`</span></div><div class="line">   TxHash      common.Hash    <span class="string">`json:"transactionsRoot" gencodec:"required"`</span></div><div class="line">   ReceiptHash common.Hash    <span class="string">`json:"receiptsRoot"     gencodec:"required"`</span></div><div class="line">   Bloom       Bloom          <span class="string">`json:"logsBloom"        gencodec:"required"`</span></div><div class="line">   Difficulty  *big.Int       <span class="string">`json:"difficulty"       gencodec:"required"`</span></div><div class="line">   Number      *big.Int       <span class="string">`json:"number"           gencodec:"required"`</span></div><div class="line">   GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:"gasLimit"         gencodec:"required"`</span></div><div class="line">   GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:"gasUsed"          gencodec:"required"`</span></div><div class="line">   Time        *big.Int       <span class="string">`json:"timestamp"        gencodec:"required"`</span></div><div class="line">   Extra       []<span class="keyword">byte</span>         <span class="string">`json:"extraData"        gencodec:"required"`</span></div><div class="line">   MixDigest   common.Hash    <span class="string">`json:"mixHash"          gencodec:"required"`</span></div><div class="line">   Nonce       BlockNonce     <span class="string">`json:"nonce"            gencodec:"required"`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/2018/03/18/the-store-of-block/ethereum.png" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Block represents an entire block in the Ethereum blockchain.</span></div><div class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</div><div class="line">   header       *Header</div><div class="line">   uncles       []*Header</div><div class="line">   transactions Transactions</div><div class="line"></div><div class="line">   <span class="comment">// caches</span></div><div class="line">   hash atomic.Value</div><div class="line">   size atomic.Value</div><div class="line"></div><div class="line">   <span class="comment">// Td is used by package core to store the total difficulty</span></div><div class="line">   <span class="comment">// of the chain up to and including the block.</span></div><div class="line">   td *big.Int</div><div class="line"></div><div class="line">   <span class="comment">// These fields are used by package eth to track</span></div><div class="line">   <span class="comment">// inter-peer block relay.</span></div><div class="line">   ReceivedAt   time.Time</div><div class="line">   ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Transaction是Body的重要数据结构，一个交易就是被外部拥有账户生成的加密签名的一段指令，序列化，然后提交给区块链。</p>
<p>在这里保存区块信息时，key一般是与hash相关的，value所保存的数据结构是经过RLP编码的。<br>在代码中，core/database_util.go中封装了区块存储和读取相关的代码。<br>在存储区块信息时，会将区块头和区块体分开进行存储。因此在区块的结构体中，能够看到Header和Body两个结构体。<br>区块头（Header）的存储格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">headerPrefix + num (<span class="keyword">uint64</span> big endian) + hash -&gt; rlpEncode(header)</div></pre></td></tr></table></figure>
<p>key是由区块头的前缀，区块号和区块hash构成。value是区块头的RLP编码。<br>区块体（Body）的存储格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bodyPrefix + num (<span class="keyword">uint64</span> big endian) + hash -&gt; rlpEncode(block body)</div></pre></td></tr></table></figure>
<p>key是由区块体前缀，区块号和区块hash构成。value是区块体的RLP编码。<br>在database_util.go中，key的前缀可以区分leveldb中存储的是什么类型的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    headHeaderKey = []<span class="keyword">byte</span>(<span class="string">"LastHeader"</span>)</div><div class="line">    headBlockKey  = []<span class="keyword">byte</span>(<span class="string">"LastBlock"</span>)</div><div class="line">    headFastKey   = []<span class="keyword">byte</span>(<span class="string">"LastFast"</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Data item prefixes (use single byte to avoid mixing data types, avoid `i`).</span></div><div class="line">    headerPrefix        = []<span class="keyword">byte</span>(<span class="string">"h"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + hash -&gt; header</span></div><div class="line">    tdSuffix            = []<span class="keyword">byte</span>(<span class="string">"t"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + hash + tdSuffix -&gt; td</span></div><div class="line">    numSuffix           = []<span class="keyword">byte</span>(<span class="string">"n"</span>) <span class="comment">// headerPrefix + num (uint64 big endian) + numSuffix -&gt; hash</span></div><div class="line">    blockHashPrefix     = []<span class="keyword">byte</span>(<span class="string">"H"</span>) <span class="comment">// blockHashPrefix + hash -&gt; num (uint64 big endian)</span></div><div class="line">    bodyPrefix          = []<span class="keyword">byte</span>(<span class="string">"b"</span>) <span class="comment">// bodyPrefix + num (uint64 big endian) + hash -&gt; block body</span></div><div class="line">    blockReceiptsPrefix = []<span class="keyword">byte</span>(<span class="string">"r"</span>) <span class="comment">// blockReceiptsPrefix + num (uint64 big endian) + hash -&gt; block receipts</span></div><div class="line">    lookupPrefix        = []<span class="keyword">byte</span>(<span class="string">"l"</span>) <span class="comment">// lookupPrefix + hash -&gt; transaction/receipt lookup metadata</span></div><div class="line">    bloomBitsPrefix     = []<span class="keyword">byte</span>(<span class="string">"B"</span>) <span class="comment">// bloomBitsPrefix + bit (uint16 big endian) + section (uint64 big endian) + hash -&gt; bloom bits</span></div><div class="line"></div><div class="line">    preimagePrefix = <span class="string">"secure-key-"</span>              <span class="comment">// preimagePrefix + hash -&gt; preimage</span></div><div class="line">    configPrefix   = []<span class="keyword">byte</span>(<span class="string">"ethereum-config-"</span>) <span class="comment">// config prefix for the db</span></div><div class="line"></div><div class="line">    <span class="comment">// Chain index prefixes (use `i` + single byte to avoid mixing data types).</span></div><div class="line">    BloomBitsIndexPrefix = []<span class="keyword">byte</span>(<span class="string">"iB"</span>) <span class="comment">// BloomBitsIndexPrefix is the data table of a chain indexer to track its progress</span></div><div class="line"></div><div class="line">    <span class="comment">// used by old db, now only used for conversion</span></div><div class="line">    oldReceiptsPrefix = []<span class="keyword">byte</span>(<span class="string">"receipts-"</span>)</div><div class="line">    oldTxMetaSuffix   = []<span class="keyword">byte</span>&#123;<span class="number">0x01</span>&#125;</div><div class="line"></div><div class="line">    ErrChainConfigNotFound = errors.New(<span class="string">"ChainConfig not found"</span>) <span class="comment">// general config not found error</span></div><div class="line"></div><div class="line">    preimageCounter    = metrics.NewCounter(<span class="string">"db/preimage/total"</span>)</div><div class="line">    preimageHitCounter = metrics.NewCounter(<span class="string">"db/preimage/hits"</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>database_util.go最开始就定义了所有的前缀。这里的注释详细说明了每一个前缀存储了什么数据类型。<br>database_util.go中的其他方法则是对leveldb的操作。其中get方法是读取数据库中的内容，write则是向leveldb中写入数据。<br>要讲一个区块的信息写入数据库，则需要调用其中的WriteBlock方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WriteBlock serializes a block into the database, header and body separately.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">WriteBlock</span><span class="params">(db ethdb.Putter, block *types.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">        <span class="comment">// Store the body first to retain database consistency</span></div><div class="line">        <span class="keyword">if</span> err := WriteBody(db, block.Hash(), block.NumberU64(), block.Body()); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Store the header too, signaling full block ownership</span></div><div class="line">        <span class="keyword">if</span> err := WriteHeader(db, block.Header()); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里我们看到，将一个区块信息写入数据库其实是分别将区块头和区块体写入数据库。<br>首先来看区块头的存储。区块头的存储是由WriteHeader方法完成的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WriteHeader serializes a block header into the database.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteHeader</span><span class="params">(db ethdb.Putter, header *types.Header)</span> <span class="title">error</span></span> &#123;</div><div class="line">    data, err := rlp.EncodeToBytes(header)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125;</div><div class="line">    hash := header.Hash().Bytes()</div><div class="line">    num := header.Number.Uint64()</div><div class="line">    encNum := encodeBlockNumber(num)</div><div class="line">    key := <span class="built_in">append</span>(blockHashPrefix, hash...)</div><div class="line">    <span class="keyword">if</span> err := db.Put(key, encNum); err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Crit(<span class="string">"Failed to store hash to number mapping"</span>, <span class="string">"err"</span>, err)</div><div class="line">    &#125;</div><div class="line">    key = <span class="built_in">append</span>(<span class="built_in">append</span>(headerPrefix, encNum...), hash...)</div><div class="line">    <span class="keyword">if</span> err := db.Put(key, data); err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Crit(<span class="string">"Failed to store header"</span>, <span class="string">"err"</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先对区块头进行了RLP编码，然后将区块号转换成为byte格式，开始组装key。<br>这里首先向数据库中存储了一条区块hash-&gt;区块号的键值对，然后才将区块头的信息写入数据库。<br>接下来是区块体的存储。区块体存储是由WriteBody方法实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WriteBody serializes the body of a block into the database.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">WriteBody</span><span class="params">(db ethdb.Putter, hash common.Hash, number <span class="keyword">uint64</span>, body *types.Body)</span> <span class="title">error</span></span> &#123;</div><div class="line">        data, err := rlp.EncodeToBytes(body)</div><div class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> err</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> WriteBodyRLP(db, hash, number, data)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// WriteBodyRLP writes a serialized body of a block into the database.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">WriteBodyRLP</span><span class="params">(db ethdb.Putter, hash common.Hash, number <span class="keyword">uint64</span>, rlp rlp.RawValue)</span> <span class="title">error</span></span> &#123;</div><div class="line">        key := <span class="built_in">append</span>(<span class="built_in">append</span>(bodyPrefix, encodeBlockNumber(number)...), hash.Bytes()...)</div><div class="line">        <span class="keyword">if</span> err := db.Put(key, rlp); err != <span class="literal">nil</span> &#123;</div><div class="line">            log.Crit(<span class="string">"Failed to store block body"</span>, <span class="string">"err"</span>, err)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>WriteBody首先将区块体的信息进行RLP编码，然后调用WriteBodyRLP方法将区块体的信息写入数据库。key的组装方法如之前所述。</p>
<h2 id="交易存储"><a href="#交易存储" class="headerlink" title="交易存储"></a>交易存储</h2><p>交易主要在数据库中仅存储交易的Meta信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">txHash + txMetaSuffix -&gt; rlpEncode(txMeta)</div></pre></td></tr></table></figure>
<p>交易的Meta信息结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TxLookupEntry is a positional metadata to help looking up the data content of</span></div><div class="line"><span class="comment">// a transaction or receipt given only its hash.</span></div><div class="line">    <span class="keyword">type</span> TxLookupEntry <span class="keyword">struct</span> &#123;</div><div class="line">        BlockHash  common.Hash</div><div class="line">        BlockIndex <span class="keyword">uint64</span></div><div class="line">        Index      <span class="keyword">uint64</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里，meta信息会存储块的hash，块号和块上第几笔交易这些信息。<br>交易Meta存储是以交易hash加交易的Meta前缀为key，Meta的RLP编码为value。<br>交易写入数据库是通过WriteTxLookupEntries方法实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WriteTxLookupEntries stores a positional metadata for every transaction from</span></div><div class="line"><span class="comment">// a block, enabling hash based transaction and receipt lookups.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">WriteTxLookupEntries</span><span class="params">(db ethdb.Putter, block *types.Block)</span> <span class="title">error</span></span> &#123;</div><div class="line">        <span class="comment">// Iterate over each transaction and encode its metadata</span></div><div class="line">        <span class="keyword">for</span> i, tx := <span class="keyword">range</span> block.Transactions() &#123;</div><div class="line">            entry := TxLookupEntry&#123;</div><div class="line">                BlockHash:  block.Hash(),</div><div class="line">                BlockIndex: block.NumberU64(),</div><div class="line">                Index:      <span class="keyword">uint64</span>(i),</div><div class="line">            &#125;</div><div class="line">            data, err := rlp.EncodeToBytes(entry)</div><div class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> err := db.Put(<span class="built_in">append</span>(lookupPrefix, tx.Hash().Bytes()...), data); err != <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里，在将交易meta入库时，会遍历块上的所有交易，并构造交易的meta信息，进行RLP编码。然后以交易hash为key，meta为value进行存储。<br>这样就将一笔交易写入数据库中。<br>从数据库中读取交易信息时通过GetTransaction方法获得的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GetTransaction retrieves a specific transaction from the database, along with</span></div><div class="line"><span class="comment">// its added positional metadata.</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">GetTransaction</span><span class="params">(db DatabaseReader, hash common.Hash)</span> <span class="params">(*types.Transaction, common.Hash, <span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</span></span> &#123;</div><div class="line">        <span class="comment">// Retrieve the lookup metadata and resolve the transaction from the body</span></div><div class="line">        blockHash, blockNumber, txIndex := GetTxLookupEntry(db, hash)</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> blockHash != (common.Hash&#123;&#125;) &#123;</div><div class="line">            body := GetBody(db, blockHash, blockNumber)</div><div class="line">            <span class="keyword">if</span> body == <span class="literal">nil</span> || <span class="built_in">len</span>(body.Transactions) &lt;= <span class="keyword">int</span>(txIndex) &#123;</div><div class="line">                log.Error(<span class="string">"Transaction referenced missing"</span>, <span class="string">"number"</span>, blockNumber, <span class="string">"hash"</span>, blockHash, <span class="string">"index"</span>, txIndex)</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> body.Transactions[txIndex], blockHash, blockNumber, txIndex</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Old transaction representation, load the transaction and it's metadata separately</span></div><div class="line">        data, _ := db.Get(hash.Bytes())</div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> tx types.Transaction</div><div class="line">        <span class="keyword">if</span> err := rlp.DecodeBytes(data, &amp;tx); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Retrieve the blockchain positional metadata</span></div><div class="line">        data, _ = db.Get(<span class="built_in">append</span>(hash.Bytes(), oldTxMetaSuffix...))</div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> entry TxLookupEntry</div><div class="line">        <span class="keyword">if</span> err := rlp.DecodeBytes(data, &amp;entry); err != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, common.Hash&#123;&#125;, <span class="number">0</span>, <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> &amp;tx, entry.BlockHash, entry.BlockIndex, entry.Index</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法会首先通过交易hash从数据库中获取交易的meta信息，包括交易所在块的hash，块号和第几笔交易。<br>接下来使用块号和块hash获取从数据库中读取块的信息。<br>然后根据第几笔交易从块上获取交易的具体信息。<br>这里以太坊将交易的存储换成了新的存储方式，即交易的具体信息存储在块上，交易hash只对应交易的meta信息，并不包含交易的具体信息。<br>而以前的交易存储则是需要存储交易的具体信息和meta信息。<br>因此GetTransaction方法会支持原有的数据存储方式。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/BlockChain/">BlockChain</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/BlockChain/">BlockChain</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yangchenglong11.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/BlockChain/">BlockChain</a><small>7</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>15</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/categories/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/categories/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/04/10/PoA/">PoA</a>
      </li>
    
      <li>
        <a href="/2018/03/26/mine/">mine</a>
      </li>
    
      <li>
        <a href="/2018/03/18/the-store-of-block/">区块存储</a>
      </li>
    
      <li>
        <a href="/2018/03/16/merkle-patricia-tree/">Merkle Patricia Tree (梅克尔帕特里夏树) 详解</a>
      </li>
    
      <li>
        <a href="/2018/03/13/the-basic-of-ethereum/">初识以太坊</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BlockChain/">BlockChain</a><small>7</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/tags/Golang/">Golang</a><small>16</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/tags/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BlockChain/" style="font-size: 17.5px;">BlockChain</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 12.5px;">MongoDB</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 Yang Chenglong
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="300" height="400" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -50px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/tororo/tororo.model.json",0.5)</script>
  
</body>
</html>