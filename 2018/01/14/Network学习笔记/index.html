<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Network学习笔记 | yangcl&#39;s</title>
  <meta name="author" content="Yang Chenglong" />

  
  <meta name="description" content="Yangcl&#39;s Blog" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Network学习笔记" />
  <meta property="og:site_name" content="yangcl&#39;s" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="yangcl&#39;s" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">yangcl&#39;s</a></h1>
  <h2><a href="/">悟已往之不谏，知来者之可追。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/atom.xml">RSS</a></li>
    
      <li><a href="https://github.com/yangchenglong11">github</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-01-14T04:42:40.000Z"><a href="/2018/01/14/Network学习笔记/">2018-01-14</a></time>
      
      
  
    <h1 class="title">Network学习笔记</h1>
  

    </header>
    <div class="entry">
      
        <p>整理了一些网络学习中易混淆的名词。<br><a id="more"></a></p>
<p>说到网络，不得不提的就是分层模型。</p>
<table>
<thead>
<tr>
<th>七层模型</th>
<th>五层模型</th>
<th>四层模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层</td>
<td>链接层/实体层</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
</tr>
</tbody>
</table>
<p>七层模型的上三层归为应用层即为TCP/IP五层模型，五层模型的下两层归为链接层或者说实体层即为四层模型。</p>
<p>也就是说，所谓的五层或者四层，其实可以认为是方便理解而形成的潜规则，而具体的实施肯定还是得根据七层的标准来。毕竟每一层都有每一层各自的功能，而为了完成每一层的功能，就需要大家遵守相关的规则，也就是协议。</p>
<p><strong>IP</strong></p>
<p> IP协议（网际协议）对应于网络层，在网络通信中，网络组件的寻址对信息的路由选择和传输来说是相当关键的。相同网络中的两台机器间的消息传输有各自的技术协定。LAN 是通过提供6字节的唯一标识符（“MAC”地址）在机器间发送消息的。SNA 网络中的每台机器都有一个逻辑单元及与其相应的网络地址。</p>
<p><strong>TCP</strong> </p>
<p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)</p>
<p>通过序列化应答和必要时重发数据包，TCP 为应用程序提供了可靠的传输流和虚拟连接服务，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。TCP 还提供有效流控制，全双工操作和多路传输技术。</p>
<p>TCP是传输层协议，每一条TCP连接只能是点到点的，数据包在网络传输过程中，HTTP被封装在TCP包内。</p>
<p><strong>UDP</strong></p>
<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！</p>
<p>UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实 “ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如， 在默认状态下，一次“ping”操作发送4个数据包。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一 个确认收到的数据包）。</p>
<p>这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好通信效果高。但也正因为如此，它的可靠性不如TCP协议高，可能会出现先发未必先至现象。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。</p>
<p>UDP支持一对一，一对多，多对一和多对多的交互通信，可以实现广播。</p>
<p>知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p>
<p><strong>HTTP</strong></p>
<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。HTTP是无状态的短连接，就是经过一次一来一回的即断开连接。无法记录状态，所以引进session还有cookie弥补他无状态的缺陷。</p>
<p><strong>WebSocket</strong></p>
<p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化，但WebSocket不仅仅在Web应用程序上得到支持。</p>
<p>WebSocket是在H5之后发布的，可以实现双向通信，也是基于TCP的应用层协议。 在他的握手请求中会比HTTP协议多出两行代码:</p>
<pre><code>Upgrade: websocket
Connection: Upgrade
</code></pre><p>他保证了服务器识别该协议为WebSocket协议。</p>
<p>总结一下，TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p>
<p>关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，除 HTTP ，WebSocket外还有 FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>
<p>HTTP通信过程属于“你推一下，我走一下”的方式，客户端不发请求则服务器永远无法发送数据给客户端。在HTTP上实现长连接以前可用AJAX轮询(就是隔一段时间发送ajax来保证数据，但这样会耗费大量资源)。而WebSocket则在进行第一次HTTP请求之后，其他全部采用TCP通道进行双向通讯。所以，HTTP和WebSocket虽都是基于TCP协议，但是两者属于完全不同的两种通讯方式。</p>
<p><strong>Socket</strong></p>
<p>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。</p>
<p>Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。<br>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p>
<p>为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p>
<p>而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<p>传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/Network/">Network</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Network/">Network</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yangchenglong11.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/BlockChain/">BlockChain</a><small>5</small></li>
  
    <li><a href="/categories/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/categories/Golang/">Golang</a><small>15</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/categories/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/categories/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/03/18/the-store-of-block/">区块存储</a>
      </li>
    
      <li>
        <a href="/2018/03/16/merkle-patricia-tree/">Merkle Patricia Tree (梅克尔帕特里夏树) 详解</a>
      </li>
    
      <li>
        <a href="/2018/03/13/the-basic-of-ethereum/">初识以太坊</a>
      </li>
    
      <li>
        <a href="/2018/03/11/transaction-and-scripts-of-bitcoin/">比特币分析之交易、脚本</a>
      </li>
    
      <li>
        <a href="/2018/03/09/the-basic-of-bitcoin/">区块链是什么</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/BlockChain/">BlockChain</a><small>5</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>1</small></li>
  
    <li><a href="/tags/Golang/">Golang</a><small>16</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>4</small></li>
  
    <li><a href="/tags/Network/">Network</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/BlockChain/" style="font-size: 16.67px;">BlockChain</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Golang/" style="font-size: 20px;">Golang</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 13.33px;">MongoDB</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2018 Yang Chenglong
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
  
    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="300" height="400" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -50px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/tororo/tororo.model.json",0.5)</script>
  
</body>
</html>