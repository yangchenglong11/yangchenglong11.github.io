<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  	<meta property="og:title" content=" Docker基本命令 &middot;  My New Hugo Site" />
  	<meta property="og:site_name" content="My New Hugo Site" />
  	<meta property="og:url" content="http://yangchenglong11.github.io/post/dotscale-2014-as-a-sketch/" />
    
    
  	<meta property="og:type" content="article" />

    <meta property="og:article:published_time" content="2017-05-12T13:48:24&#43;08:00" />

    
    <meta property="og:article:tag" content="event" />
    
    <meta property="og:article:tag" content="dotScale" />
    
    <meta property="og:article:tag" content="sketchnote" />
    
    

  <title>
     Docker基本命令 &middot;  My New Hugo Site
  </title>

    <meta name="description" content="" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="http://yangchenglong11.github.io/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://yangchenglong11.github.io/images/apple-touch-icon.png" />
    
    <link rel="stylesheet" type="text/css" href="http://yangchenglong11.github.io/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata" />


    
      
          <link href="http://yangchenglong11.github.io/index.xml" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
      
      
    
    <meta name="generator" content="Hugo 0.20.7" />

    <link rel="canonical" href="http://yangchenglong11.github.io/post/dotscale-2014-as-a-sketch/" />

    
<div id="particles-js"></div>
<script src="http://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script src="http://yangchenglong11.github.io/js/particles.js"></script>   
</head>
<body class="nav-closed">

  


 <div class="site-wrapper">



<header class="main-header " style="background-image: url(http://yangchenglong11.github.io/)">
    
    <nav class="main-nav overlay clearfix">
        
        
    </nav>
<div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">
              <a class="btn-bootstrap-2" href="#content">My New Hugo Site</a>
          </h1>
          <h2 class="page-description"></h2>
        </div>
</div>
    <a class="scroll-down icon-arrow-left" href="#content"><span class="hidden">Scroll Down</span></a>
</header>

  <main id="content" class="content" role="main">


  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Docker基本命令</h1>
        <section class="post-meta">
        
          <time class="post-date" datetime="2017-05-12T13:48:24&#43;08:00">
            May 12, 2017
          </time>
        
         
          <span class="post-tag small"><a href="http://yangchenglong11.github.io/tags/event/">#event</a></span>
         
          <span class="post-tag small"><a href="http://yangchenglong11.github.io/tags/dotscale/">#dotScale</a></span>
         
          <span class="post-tag small"><a href="http://yangchenglong11.github.io/tags/sketchnote/">#sketchnote</a></span>
         
        </section>
    </header>
  
    <section class="post-content">
      <p>docker
创建mongo容器，并在其他端口启动</p>

<p><code>docker run --name clmongo -p 6667:27017 -d mongo</code></p>

<p>创建mongo容器，将数据放在 /home/docker/clmongo_data目录下，在本机27017端口启动，在外部通过6667访问</p>

<p><code>docker run --name clmongo -v /home/docker/clmongo_data:/data/db -d -p 6667:27017 mongo</code></p>

<p>获取镜像，通过制定tag可以下载特定标签的镜像。比如
<code>docker pull image_name:tag</code></p>

<p>未指定tag时，将会默认下载标签为latest标签的镜像</p>

<p><code>sudo docker pull ubuntu:14.04</code></p>

<p>使用镜像</p>

<p><code>sudo docker run -t -i ubuntu /bin</code></p>

<p>查看镜像信息</p>

<p><code>docker imges</code></p>

<p>使用docker tag为本地镜像添加新的标签, 添加后可以发现多了一个所添加标签的镜像，但它们标签一致，即标签在这里起到了引用或快捷方式的作用。</p>

<p><code>sudo docker tag name:tag new_name:new_tag</code></p>

<p>显示 Docker 系统信息，包括镜像和容器数。</p>

<p><code>docker info</code></p>

<p>使用docker inspect查看该镜像的详细信息</p>

<p><code>sudo docker inspect image_id</code></p>

<p>查询镜像</p>

<p><code>sudo docker search name</code></p>

<p>删除镜像</p>

<p><code>sudo docker mi</code></p>

    </section>


  <footer class="post-footer">


    

    





<section class="author">
  <h4><a href="http://yangchenglong11.github.io/"></a></h4>
  
  <p>Read <a href="http://yangchenglong11.github.io/">more posts</a> by this author.</p>
  
  <div class="author-meta">
    
    
  </div>
</section>



    
    <section class="share">
      <h4>Share this post</h4>
      <a class="icon-twitter" style="font-size: 1.4em" href="https://twitter.com/share?text=Docker%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4&amp;url=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
      </a>
      <a class="icon-facebook" style="font-size: 1.4em" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
      </a>
      <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
         onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
      </a>
    </section>
    

    
    
    

  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">My New Hugo Site</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/index.js"></script>

</body>
</html>

one is provided for use in select statements:
    	//
    	//  // Stream generates values with DoSomething and sends them to out
    	//  // until DoSomething returns an error or ctx.Done is closed.
    	//  func Stream(ctx context.Context, out chan&lt;- Value) error {
    	//  	for {
    	//  		v, err := DoSomething(ctx)
    	//  		if err != nil {
    	//  			return err
    	//  		}
    	//  		select {
    	//  		case &lt;-ctx.Done():
    	//  			return ctx.Err()
    	//  		case out &lt;- v:
    	//  		}
    	//  	}
    	//  }
    	//
    	// See https://blog.golang.org/pipelines for more examples of how to use
    	// a Done channel for cancelation.
      // 当Context 被 canceled 或是 times out 的时候，Done 返回一个被 closed 的channel
    	Done() &lt;-chan struct{}
    
    	// Err returns a non-nil error value after Done is closed. Err returns
    	// Canceled if the context was canceled or DeadlineExceeded if the
    	// context's deadline passed. No other values for Err are defined.
    	// After Done is closed, successive calls to Err return the same value.
      
      // 在 Done 的 channel被closed 后， Err 代表被关闭的原因  
    	Err() error
    
    	// Value returns the value associated with this context for key, or nil
    	// if no value is associated with key. Successive calls to Value with
    	// the same key returns the same result.
    	//
    	// Use context values only for request-scoped data that transits
    	// processes and API boundaries, not for passing optional parameters to
    	// functions.
    	//
    	// A key identifies a specific value in a Context. Functions that wish
    	// to store values in Context typically allocate a key in a global
    	// variable then use that key as the argument to context.WithValue and
    	// Context.Value. A key can be any type that supports equality;
    	// packages should define keys as an unexported type to avoid
    	// collisions.
    	//
    	// Packages that define a Context key should provide type-safe accessors
    	// for the values stored using that key:
    	//
    	// 	// Package user defines a User type that's stored in Contexts.
    	// 	package user
    	//
    	// 	import &quot;context&quot;
    	//
    	// 	// User is the type of value stored in the Contexts.
    	// 	type User struct {...}
    	//
    	// 	// key is an unexported type for keys defined in this package.
    	// 	// This prevents collisions with keys defined in other packages.
    	// 	type key int
    	//
    	// 	// userKey is the key for user.User values in Contexts. It is
    	// 	// unexported; clients use user.NewContext and user.FromContext
    	// 	// instead of using this key directly.
    	// 	var userKey key = 0
    	//
    	// 	// NewContext returns a new Context that carries value u.
    	// 	func NewContext(ctx context.Context, u *User) context.Context {
    	// 		return context.WithValue(ctx, userKey, u)
    	// 	}
    	//
    	// 	// FromContext returns the User value stored in ctx, if any.
    	// 	func FromContext(ctx context.Context) (*User, bool) {
    	// 		u, ok := ctx.Value(userKey).(*User)
    	// 		return u, ok
    	// 	}
      
      // 如果存在，Value 返回与 key 相关了的值，不存在返回 nil  
    	Value(key interface{}) interface{}
    }
    
    //定义错误类型，共分两类，分别是Cancel和Timeout时对应的错误。
    // Canceled is the error returned by Context.Err when the context is canceled.
    var Canceled = errors.New(&quot;context canceled&quot;)
    
    // DeadlineExceeded is the error returned by Context.Err when the context's
    // deadline passes.
    var DeadlineExceeded error = deadlineExceededError{}
    
    type deadlineExceededError struct{}
    
    //为该接口添加一系列方法
    func (deadlineExceededError) Error() string   { return &quot;context deadline exceeded&quot; }
    func (deadlineExceededError) Timeout() bool   { return true }
    func (deadlineExceededError) Temporary() bool { return true }
    
    // An emptyCtx is never canceled, has no values, and has no deadline. It is not
    // struct{}, since vars of this type must have distinct addresses.
    
    //定义emptyContext，并实现Context接口
    type emptyCtx int
    
    func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    	return
    }
    
    //需要特别注意，emptyContent的Done和Err以及Value方法返回都为nil
    func (*emptyCtx) Done() &lt;-chan struct{} {
    	return nil
    }
    
    func (*emptyCtx) Err() error {
    	return nil
    }
    
    func (*emptyCtx) Value(key interface{}) interface{} {
    	return nil
    }
    
     //此处相当于print函数，当需要输出时系统自动调用。
    //需要注意一点，即用户自定义的Context类型会返回unknown empty Context，所以自定义类型时，需要重写该方法
    func (e *emptyCtx) String() string {
    	switch e {
    	case background:
    		return &quot;context.Background&quot;
    	case todo:
    		return &quot;context.TODO&quot;
    	}
    	return &quot;unknown empty Context&quot;
    }
    
    //定义两个根Context，不可被Cancel，其类型为emptyContext，且创建时使用new创建，即为地址
    var (
    	background = new(emptyCtx)
    	todo       = new(emptyCtx)
    )
    
    // Background returns a non-nil, empty Context. It is never canceled, has no
    // values, and has no deadline. It is typically used by the main function,
    // initialization, and tests, and as the top-level Context for incoming
    // requests.
    
    //background和todo为小写，外部无法访问，提供接口访问
    func Background() Context {
    	return background
    }
    
    // TODO returns a non-nil, empty Context. Code should use context.TODO when
    // it's unclear which Context to use or it is not yet available (because the
    // surrounding function has not yet been extended to accept a Context
    // parameter). TODO is recognized by static analysis tools that determine
    // whether Contexts are propagated correctly in a program.
    func TODO() Context {
    	return todo
    }
    
    // A CancelFunc tells an operation to abandon its work.
    // A CancelFunc does not wait for the work to stop.
    // After the first call, subsequent calls to a CancelFunc do nothing.
    
    //定义无参数，无返回值函数类型，即不会出错
    type CancelFunc func()
    
    // WithCancel returns a copy of parent with a new Done channel. The returned
    // context's Done channel is closed when the returned cancel function is called
    // or when the parent context's Done channel is closed, whichever happens first.
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete.
    
    //为Context添加
    func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    	c := newCancelCtx(parent)
    	propagateCancel(parent, &amp;c)
    	return &amp;c, func() { c.cancel(true, Canceled) }
    }
    
    // newCancelCtx returns an initialized cancelCtx.
    func newCancelCtx(parent Context) cancelCtx {
    	return cancelCtx{
    		Context: parent,
    		done:    make(chan struct{}),
    	}
    }
    
    // propagateCancel arranges for child to be canceled when parent is.
    func propagateCancel(parent Context, child canceler) {
    	if parent.Done() == nil {
    		return // parent is never canceled
    	}
    	if p, ok := parentCancelCtx(parent); ok {
    		p.mu.Lock()
    		if p.err != nil {
    			// parent has already been canceled
    			child.cancel(false, p.err)
    		} else {
    			if p.children == nil {
    				p.children = make(map[canceler]struct{})
    			}
    			p.children[child] = struct{}{}
    		}
    		p.mu.Unlock()
    	} else {
    		go func() {
    			select {
    			case &lt;-parent.Done():
    				child.cancel(false, parent.Err())
    			case &lt;-child.Done():
    			}
    		}()
    	}
    }
    
    // parentCancelCtx follows a chain of parent references until it finds a
    // *cancelCtx. This function understands how each of the concrete types in this
    // package represents its parent.
    func parentCancelCtx(parent Context) (*cancelCtx, bool) {
    	for {
    		switch c := parent.(type) {
    		case *cancelCtx:
    			return c, true
    		case *timerCtx:
    			return &amp;c.cancelCtx, true
    		case *valueCtx:
    			parent = c.Context
    		default:
    			return nil, false
    		}
    	}
    }
    
    // removeChild removes a context from its parent.
    func removeChild(parent Context, child canceler) {
    	p, ok := parentCancelCtx(parent)
    	if !ok {
    		return
    	}
    	p.mu.Lock()
    	if p.children != nil {
    		delete(p.children, child)
    	}
    	p.mu.Unlock()
    }
    
    // A canceler is a context type that can be canceled directly. The
    // implementations are *cancelCtx and *timerCtx.
    type canceler interface {
    	cancel(removeFromParent bool, err error)
    	Done() &lt;-chan struct{}
    }
    
    // A cancelCtx can be canceled. When canceled, it also cancels any children
    // that implement canceler.
    type cancelCtx struct {
    	Context
    
    	done chan struct{} // closed by the first cancel call.
    
    	mu       sync.Mutex
    	children map[canceler]struct{} // set to nil by the first cancel call
    	err      error                 // set to non-nil by the first cancel call
    }
    
    func (c *cancelCtx) Done() &lt;-chan struct{} {
    	return c.done
    }
    
    func (c *cancelCtx) Err() error {
    	c.mu.Lock()
    	defer c.mu.Unlock()
    	return c.err
    }
    
    func (c *cancelCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithCancel&quot;, c.Context)
    }
    
    // cancel closes c.done, cancels each of c's children, and, if
    // removeFromParent is true, removes c from its parent's children.
    func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    	if err == nil {
    		panic(&quot;context: internal error: missing cancel error&quot;)
    	}
    	c.mu.Lock()
    	if c.err != nil {
    		c.mu.Unlock()
    		return // already canceled
    	}
    	c.err = err
    	close(c.done)
    	for child := range c.children {
    		// NOTE: acquiring the child's lock while holding parent's lock.
    		child.cancel(false, err)
    	}
    	c.children = nil
    	c.mu.Unlock()
    
    	if removeFromParent {
    		removeChild(c.Context, c)
    	}
    }
    
    // WithDeadline returns a copy of the parent context with the deadline adjusted
    // to be no later than d. If the parent's deadline is already earlier than d,
    // WithDeadline(parent, d) is semantically equivalent to parent. The returned
    // context's Done channel is closed when the deadline expires, when the returned
    // cancel function is called, or when the parent context's Done channel is
    // closed, whichever happens first.
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete.
    func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
    	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) {
    		// The current deadline is already sooner than the new one.
    		return WithCancel(parent)
    	}
    	c := &amp;timerCtx{
    		cancelCtx: newCancelCtx(parent),
    		deadline:  deadline,
    	}
    	propagateCancel(parent, c)
    	d := time.Until(deadline)
    	if d &lt;= 0 {
    		c.cancel(true, DeadlineExceeded) // deadline has already passed
    		return c, func() { c.cancel(true, Canceled) }
    	}
    	c.mu.Lock()
    	defer c.mu.Unlock()
    	if c.err == nil {
    		c.timer = time.AfterFunc(d, func() {
    			c.cancel(true, DeadlineExceeded)
    		})
    	}
    	return c, func() { c.cancel(true, Canceled) }
    }
    
    // A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
    // implement Done and Err. It implements cancel by stopping its timer then
    // delegating to cancelCtx.cancel.
    type timerCtx struct {
    	cancelCtx
    	timer *time.Timer // Under cancelCtx.mu.
    
    	deadline time.Time
    }
    
    func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
    	return c.deadline, true
    }
    
    func (c *timerCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithDeadline(%s [%s])&quot;, c.cancelCtx.Context, c.deadline, time.Until(c.deadline))
    }
    
    func (c *timerCtx) cancel(removeFromParent bool, err error) {
    	c.cancelCtx.cancel(false, err)
    	if removeFromParent {
    		// Remove this timerCtx from its parent cancelCtx's children.
    		removeChild(c.cancelCtx.Context, c)
    	}
    	c.mu.Lock()
    	if c.timer != nil {
    		c.timer.Stop()
    		c.timer = nil
    	}
    	c.mu.Unlock()
    }
    
    // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete:
    //
    // 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
    // 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    // 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
    // 		return slowOperation(ctx)
    // 	}
    func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    	return WithDeadline(parent, time.Now().Add(timeout))
    }
    
    // WithValue returns a copy of parent in which the value associated with key is
    // val.
    //
    // Use context Values only for request-scoped data that transits processes and
    // APIs, not for passing optional parameters to functions.
    //
    // The provided key must be comparable and should not be of type
    // string or any other built-in type to avoid collisions between
    // packages using context. Users of WithValue should define their own
    // types for keys. To avoid allocating when assigning to an
    // interface{}, context keys often have concrete type
    // struct{}. Alternatively, exported context key variables' static
    // type should be a pointer or interface.
    func WithValue(parent Context, key, val interface{}) Context {
    	if key == nil {
    		panic(&quot;nil key&quot;)
    	}
    	if !reflect.TypeOf(key).Comparable() {
    		panic(&quot;key is not comparable&quot;)
    	}
    	return &amp;valueCtx{parent, key, val}
    }
    
    // A valueCtx carries a key-value pair. It implements Value for that key and
    // delegates all other calls to the embedded Context.
    type valueCtx struct {
    	Context
    	key, val interface{}
    }
    
    func (c *valueCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithValue(%#v, %#v)&quot;, c.Context, c.key, c.val)
    }
    
    func (c *valueCtx) Value(key interface{}) interface{} {
    	if c.key == key {
    		return c.val
    	}
    	return c.Context.Value(key)
    }
</code></pre>

    </section>


  <footer class="post-footer">


    

    





<section class="author">
  <h4><a href="http://yangchenglong11.github.io/"></a></h4>
  
  <p>Read <a href="http://yangchenglong11.github.io/">more posts</a> by this author.</p>
  
  <div class="author-meta">
    
    
  </div>
</section>



    
    <section class="share">
      <h4>Share this post</h4>
      <a class="icon-twitter" style="font-size: 1.4em" href="https://twitter.com/share?text=context&amp;url=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
          onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
          <span class="hidden">Twitter</span>
      </a>
      <a class="icon-facebook" style="font-size: 1.4em" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
          onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <span class="hidden">Facebook</span>
      </a>
      <a class="icon-google-plus" style="font-size: 1.4em" href="https://plus.google.com/share?url=http%3a%2f%2fyangchenglong11.github.io%2fpost%2fdotscale-2014-as-a-sketch%2f"
         onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
          <span class="hidden">Google+</span>
      </a>
    </section>
    

    
    
    

  </footer>
</article>

</main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="">My New Hugo Site</a> </section>
        
        <section class="poweredby">Proudly generated by <a class="icon-hugo" href="https://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/syui/hugo-theme-air">hugo-theme-air</a> theme</section>
        
    </footer>
    </div>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/jquery.js"></script>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://yangchenglong11.github.io/js/index.js"></script>

</body>
</html>

