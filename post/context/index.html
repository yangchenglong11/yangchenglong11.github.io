	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.20.7" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>context &middot; My New Hugo Site</title>
  

  
  <link rel="stylesheet" href="http://yangchenglong11.github.io/css/poole.css">
  <link rel="stylesheet" href="http://yangchenglong11.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://yangchenglong11.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="My New Hugo Site" />
</head>

	<body class=" ">
		<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://yangchenglong11.github.io/"><h1>My New Hugo Site</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


		<div class="content container">
			<div class="post">
			 	<h1>context</h1>
			  <span class="post-date">Sun, May 14, 2017</span>
			      <!--*more*-->

<pre><code class="language-go">    // Package context defines the Context type, which carries deadlines,
    // cancelation signals, and other request-scoped values across API boundaries
    // and between processes.
    //
    // Incoming requests to a server should create a Context, and outgoing
    // calls to servers should accept a Context. The chain of function
    // calls between them must propagate the Context, optionally replacing
    // it with a derived Context created using WithCancel, WithDeadline,
    // WithTimeout, or WithValue. When a Context is canceled, all
    // Contexts derived from it are also canceled.
    //
    // The WithCancel, WithDeadline, and WithTimeout functions take a
    // Context (the parent) and return a derived Context (the child) and a
    // CancelFunc. Calling the CancelFunc cancels the child and its
    // children, removes the parent's reference to the child, and stops
    // any associated timers. Failing to call the CancelFunc leaks the
    // child and its children until the parent is canceled or the timer
    // fires. The go vet tool checks that CancelFuncs are used on all
    // control-flow paths.
    //
    // Programs that use Contexts should follow these rules to keep interfaces
    // consistent across packages and enable static analysis tools to check context
    // propagation:
    //
    // Do not store Contexts inside a struct type; instead, pass a Context
    // explicitly to each function that needs it. The Context should be the first
    // parameter, typically named ctx:
    //
    // 	func DoSomething(ctx context.Context, arg Arg) error {
    // 		// ... use ctx ...
    // 	}
    //
    // Do not pass a nil Context, even if a function permits it. Pass context.TODO
    // if you are unsure about which Context to use.
    //
    // Use context Values only for request-scoped data that transits processes and
    // APIs, not for passing optional parameters to functions.
    //
    // The same Context may be passed to functions running in different goroutines;
    // Contexts are safe for simultaneous use by multiple goroutines.
    //
    // See https://blog.golang.org/context for example code for a server that uses
    // Contexts.
    package context
    
    import (
    	&quot;errors&quot;
    	&quot;fmt&quot;
    	&quot;reflect&quot;
    	&quot;sync&quot;
    	&quot;time&quot;
    )
    
    // A Context carries a deadline, a cancelation signal, and other values across
    // API boundaries.
    //
    // Context's methods may be called by multiple goroutines simultaneously.
    //  context 包里的方法是线程安全的，可以被多个 goroutine 使用    
    // 定义Context接口
    type Context interface {
    	// Deadline returns the time when work done on behalf of this context
    	// should be canceled. Deadline returns ok==false when no deadline is
    	// set. Successive calls to Deadline return the same results.
      
      // 如果存在，Deadline 返回Context将要关闭的时间  
    	Deadline() (deadline time.Time, ok bool)
    
    	// Done returns a channel that's closed when work done on behalf of this
    	// context should be canceled. Done may return nil if this context can
    	// never be canceled. Successive calls to Done return the same value.
    	//
    	// WithCancel arranges for Done to be closed when cancel is called;
    	// WithDeadline arranges for Done to be closed when the deadline
    	// expires; WithTimeout arranges for Done to be closed when the timeout
    	// elapses.
    	//
    	// Done is provided for use in select statements:
    	//
    	//  // Stream generates values with DoSomething and sends them to out
    	//  // until DoSomething returns an error or ctx.Done is closed.
    	//  func Stream(ctx context.Context, out chan&lt;- Value) error {
    	//  	for {
    	//  		v, err := DoSomething(ctx)
    	//  		if err != nil {
    	//  			return err
    	//  		}
    	//  		select {
    	//  		case &lt;-ctx.Done():
    	//  			return ctx.Err()
    	//  		case out &lt;- v:
    	//  		}
    	//  	}
    	//  }
    	//
    	// See https://blog.golang.org/pipelines for more examples of how to use
    	// a Done channel for cancelation.
      // 当Context 被 canceled 或是 times out 的时候，Done 返回一个被 closed 的channel
    	Done() &lt;-chan struct{}
    
    	// Err returns a non-nil error value after Done is closed. Err returns
    	// Canceled if the context was canceled or DeadlineExceeded if the
    	// context's deadline passed. No other values for Err are defined.
    	// After Done is closed, successive calls to Err return the same value.
      
      // 在 Done 的 channel被closed 后， Err 代表被关闭的原因  
    	Err() error
    
    	// Value returns the value associated with this context for key, or nil
    	// if no value is associated with key. Successive calls to Value with
    	// the same key returns the same result.
    	//
    	// Use context values only for request-scoped data that transits
    	// processes and API boundaries, not for passing optional parameters to
    	// functions.
    	//
    	// A key identifies a specific value in a Context. Functions that wish
    	// to store values in Context typically allocate a key in a global
    	// variable then use that key as the argument to context.WithValue and
    	// Context.Value. A key can be any type that supports equality;
    	// packages should define keys as an unexported type to avoid
    	// collisions.
    	//
    	// Packages that define a Context key should provide type-safe accessors
    	// for the values stored using that key:
    	//
    	// 	// Package user defines a User type that's stored in Contexts.
    	// 	package user
    	//
    	// 	import &quot;context&quot;
    	//
    	// 	// User is the type of value stored in the Contexts.
    	// 	type User struct {...}
    	//
    	// 	// key is an unexported type for keys defined in this package.
    	// 	// This prevents collisions with keys defined in other packages.
    	// 	type key int
    	//
    	// 	// userKey is the key for user.User values in Contexts. It is
    	// 	// unexported; clients use user.NewContext and user.FromContext
    	// 	// instead of using this key directly.
    	// 	var userKey key = 0
    	//
    	// 	// NewContext returns a new Context that carries value u.
    	// 	func NewContext(ctx context.Context, u *User) context.Context {
    	// 		return context.WithValue(ctx, userKey, u)
    	// 	}
    	//
    	// 	// FromContext returns the User value stored in ctx, if any.
    	// 	func FromContext(ctx context.Context) (*User, bool) {
    	// 		u, ok := ctx.Value(userKey).(*User)
    	// 		return u, ok
    	// 	}
      
      // 如果存在，Value 返回与 key 相关了的值，不存在返回 nil  
    	Value(key interface{}) interface{}
    }
    
    //定义错误类型，共分两类，分别是Cancel和Timeout时对应的错误。
    // Canceled is the error returned by Context.Err when the context is canceled.
    var Canceled = errors.New(&quot;context canceled&quot;)
    
    // DeadlineExceeded is the error returned by Context.Err when the context's
    // deadline passes.
    var DeadlineExceeded error = deadlineExceededError{}
    
    type deadlineExceededError struct{}
    
    //为该接口添加一系列方法
    func (deadlineExceededError) Error() string   { return &quot;context deadline exceeded&quot; }
    func (deadlineExceededError) Timeout() bool   { return true }
    func (deadlineExceededError) Temporary() bool { return true }
    
    // An emptyCtx is never canceled, has no values, and has no deadline. It is not
    // struct{}, since vars of this type must have distinct addresses.
    
    //定义emptyContext，并实现Context接口
    type emptyCtx int
    
    func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    	return
    }
    
    //需要特别注意，emptyContent的Done和Err以及Value方法返回都为nil
    func (*emptyCtx) Done() &lt;-chan struct{} {
    	return nil
    }
    
    func (*emptyCtx) Err() error {
    	return nil
    }
    
    func (*emptyCtx) Value(key interface{}) interface{} {
    	return nil
    }
    
     //此处相当于print函数，当需要输出时系统自动调用。
    //需要注意一点，即用户自定义的Context类型会返回unknown empty Context，所以自定义类型时，需要重写该方法
    func (e *emptyCtx) String() string {
    	switch e {
    	case background:
    		return &quot;context.Background&quot;
    	case todo:
    		return &quot;context.TODO&quot;
    	}
    	return &quot;unknown empty Context&quot;
    }
    
    //定义两个根Context，不可被Cancel，其类型为emptyContext，且创建时使用new创建，即为地址
    var (
    	background = new(emptyCtx)
    	todo       = new(emptyCtx)
    )
    
    // Background returns a non-nil, empty Context. It is never canceled, has no
    // values, and has no deadline. It is typically used by the main function,
    // initialization, and tests, and as the top-level Context for incoming
    // requests.
    
    //background和todo为小写，外部无法访问，提供接口访问
    func Background() Context {
    	return background
    }
    
    // TODO returns a non-nil, empty Context. Code should use context.TODO when
    // it's unclear which Context to use or it is not yet available (because the
    // surrounding function has not yet been extended to accept a Context
    // parameter). TODO is recognized by static analysis tools that determine
    // whether Contexts are propagated correctly in a program.
    func TODO() Context {
    	return todo
    }
    
    // A CancelFunc tells an operation to abandon its work.
    // A CancelFunc does not wait for the work to stop.
    // After the first call, subsequent calls to a CancelFunc do nothing.
    
    //定义无参数，无返回值函数类型，即不会出错
    type CancelFunc func()
    
    // WithCancel returns a copy of parent with a new Done channel. The returned
    // context's Done channel is closed when the returned cancel function is called
    // or when the parent context's Done channel is closed, whichever happens first.
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete.
    
    //为Context添加
    func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    	c := newCancelCtx(parent)
    	propagateCancel(parent, &amp;c)
    	return &amp;c, func() { c.cancel(true, Canceled) }
    }
    
    // newCancelCtx returns an initialized cancelCtx.
    func newCancelCtx(parent Context) cancelCtx {
    	return cancelCtx{
    		Context: parent,
    		done:    make(chan struct{}),
    	}
    }
    
    // propagateCancel arranges for child to be canceled when parent is.
    func propagateCancel(parent Context, child canceler) {
    	if parent.Done() == nil {
    		return // parent is never canceled
    	}
    	if p, ok := parentCancelCtx(parent); ok {
    		p.mu.Lock()
    		if p.err != nil {
    			// parent has already been canceled
    			child.cancel(false, p.err)
    		} else {
    			if p.children == nil {
    				p.children = make(map[canceler]struct{})
    			}
    			p.children[child] = struct{}{}
    		}
    		p.mu.Unlock()
    	} else {
    		go func() {
    			select {
    			case &lt;-parent.Done():
    				child.cancel(false, parent.Err())
    			case &lt;-child.Done():
    			}
    		}()
    	}
    }
    
    // parentCancelCtx follows a chain of parent references until it finds a
    // *cancelCtx. This function understands how each of the concrete types in this
    // package represents its parent.
    func parentCancelCtx(parent Context) (*cancelCtx, bool) {
    	for {
    		switch c := parent.(type) {
    		case *cancelCtx:
    			return c, true
    		case *timerCtx:
    			return &amp;c.cancelCtx, true
    		case *valueCtx:
    			parent = c.Context
    		default:
    			return nil, false
    		}
    	}
    }
    
    // removeChild removes a context from its parent.
    func removeChild(parent Context, child canceler) {
    	p, ok := parentCancelCtx(parent)
    	if !ok {
    		return
    	}
    	p.mu.Lock()
    	if p.children != nil {
    		delete(p.children, child)
    	}
    	p.mu.Unlock()
    }
    
    // A canceler is a context type that can be canceled directly. The
    // implementations are *cancelCtx and *timerCtx.
    type canceler interface {
    	cancel(removeFromParent bool, err error)
    	Done() &lt;-chan struct{}
    }
    
    // A cancelCtx can be canceled. When canceled, it also cancels any children
    // that implement canceler.
    type cancelCtx struct {
    	Context
    
    	done chan struct{} // closed by the first cancel call.
    
    	mu       sync.Mutex
    	children map[canceler]struct{} // set to nil by the first cancel call
    	err      error                 // set to non-nil by the first cancel call
    }
    
    func (c *cancelCtx) Done() &lt;-chan struct{} {
    	return c.done
    }
    
    func (c *cancelCtx) Err() error {
    	c.mu.Lock()
    	defer c.mu.Unlock()
    	return c.err
    }
    
    func (c *cancelCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithCancel&quot;, c.Context)
    }
    
    // cancel closes c.done, cancels each of c's children, and, if
    // removeFromParent is true, removes c from its parent's children.
    func (c *cancelCtx) cancel(removeFromParent bool, err error) {
    	if err == nil {
    		panic(&quot;context: internal error: missing cancel error&quot;)
    	}
    	c.mu.Lock()
    	if c.err != nil {
    		c.mu.Unlock()
    		return // already canceled
    	}
    	c.err = err
    	close(c.done)
    	for child := range c.children {
    		// NOTE: acquiring the child's lock while holding parent's lock.
    		child.cancel(false, err)
    	}
    	c.children = nil
    	c.mu.Unlock()
    
    	if removeFromParent {
    		removeChild(c.Context, c)
    	}
    }
    
    // WithDeadline returns a copy of the parent context with the deadline adjusted
    // to be no later than d. If the parent's deadline is already earlier than d,
    // WithDeadline(parent, d) is semantically equivalent to parent. The returned
    // context's Done channel is closed when the deadline expires, when the returned
    // cancel function is called, or when the parent context's Done channel is
    // closed, whichever happens first.
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete.
    func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
    	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(deadline) {
    		// The current deadline is already sooner than the new one.
    		return WithCancel(parent)
    	}
    	c := &amp;timerCtx{
    		cancelCtx: newCancelCtx(parent),
    		deadline:  deadline,
    	}
    	propagateCancel(parent, c)
    	d := time.Until(deadline)
    	if d &lt;= 0 {
    		c.cancel(true, DeadlineExceeded) // deadline has already passed
    		return c, func() { c.cancel(true, Canceled) }
    	}
    	c.mu.Lock()
    	defer c.mu.Unlock()
    	if c.err == nil {
    		c.timer = time.AfterFunc(d, func() {
    			c.cancel(true, DeadlineExceeded)
    		})
    	}
    	return c, func() { c.cancel(true, Canceled) }
    }
    
    // A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
    // implement Done and Err. It implements cancel by stopping its timer then
    // delegating to cancelCtx.cancel.
    type timerCtx struct {
    	cancelCtx
    	timer *time.Timer // Under cancelCtx.mu.
    
    	deadline time.Time
    }
    
    func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
    	return c.deadline, true
    }
    
    func (c *timerCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithDeadline(%s [%s])&quot;, c.cancelCtx.Context, c.deadline, time.Until(c.deadline))
    }
    
    func (c *timerCtx) cancel(removeFromParent bool, err error) {
    	c.cancelCtx.cancel(false, err)
    	if removeFromParent {
    		// Remove this timerCtx from its parent cancelCtx's children.
    		removeChild(c.cancelCtx.Context, c)
    	}
    	c.mu.Lock()
    	if c.timer != nil {
    		c.timer.Stop()
    		c.timer = nil
    	}
    	c.mu.Unlock()
    }
    
    // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
    //
    // Canceling this context releases resources associated with it, so code should
    // call cancel as soon as the operations running in this Context complete:
    //
    // 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
    // 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    // 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
    // 		return slowOperation(ctx)
    // 	}
    func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    	return WithDeadline(parent, time.Now().Add(timeout))
    }
    
    // WithValue returns a copy of parent in which the value associated with key is
    // val.
    //
    // Use context Values only for request-scoped data that transits processes and
    // APIs, not for passing optional parameters to functions.
    //
    // The provided key must be comparable and should not be of type
    // string or any other built-in type to avoid collisions between
    // packages using context. Users of WithValue should define their own
    // types for keys. To avoid allocating when assigning to an
    // interface{}, context keys often have concrete type
    // struct{}. Alternatively, exported context key variables' static
    // type should be a pointer or interface.
    func WithValue(parent Context, key, val interface{}) Context {
    	if key == nil {
    		panic(&quot;nil key&quot;)
    	}
    	if !reflect.TypeOf(key).Comparable() {
    		panic(&quot;key is not comparable&quot;)
    	}
    	return &amp;valueCtx{parent, key, val}
    }
    
    // A valueCtx carries a key-value pair. It implements Value for that key and
    // delegates all other calls to the embedded Context.
    type valueCtx struct {
    	Context
    	key, val interface{}
    }
    
    func (c *valueCtx) String() string {
    	return fmt.Sprintf(&quot;%v.WithValue(%#v, %#v)&quot;, c.Context, c.key, c.val)
    }
    
    func (c *valueCtx) Value(key interface{}) interface{} {
    	if c.key == key {
    		return c.val
    	}
    	return c.Context.Value(key)
    }
</code></pre>

			</div>

			
		</div>

  </body>
</html>
